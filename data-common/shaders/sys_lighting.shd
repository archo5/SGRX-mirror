#include "__eq"


struct VSOUT
{
	float4 tex0 : TEXCOORD0;
	float4 tex1 : TEXCOORD1;
	float4 viewPos : TEXCOORD2;
	float3 N : TEXCOORD3;
	float4 T : TEXCOORD4;
	float4 col : COLOR0;
#if NUM_SPOTLIGHTS > 0
	float4 SLPPos0 : TEXCOORD5;
#if NUM_SPOTLIGHTS > 1
	float4 SLPPos1 : TEXCOORD6;
#endif // NUM_SPOTLIGHTS > 1
#endif // NUM_SPOTLIGHTS > 0
	float4 pos : SEMANTIC_VSOUT_POS;
};

struct PointLight /* size: 2c */
{
	float4 vposrad;
	float4 colpow;
};
struct SpotLight /* size: 4c */
{
	PointLight PL;
	float4 vdirang;
	float4 shminfo;
};


UNIFORM_BUFFER( core_data, 0 )
	UNIFORM_VAR( float4x4 mView, 0 );
	UNIFORM_VAR( float4x4 mProj, 4 );
	UNIFORM_VAR( float4x4 mInvView, 8 );
	UNIFORM_VAR( float3 cameraPos, 12 );
	UNIFORM_VAR( float4 timeVals, 13 );
	UNIFORM_VAR( float4 viewportSizeInv, 14 );
	UNIFORM_VAR( float3 gAmbLightColor, 15 );
	UNIFORM_VAR( float3 gDirLightDir, 16 );
	UNIFORM_VAR( float3 gDirLightColor, 17 );
UNIFORM_BUFFER_END;

UNIFORM_BUFFER( instance_data, 1 )
	UNIFORM_VAR( float4x4 mWorld, 17 );
	UNIFORM_VAR( float4x4 mWorldView, 21 );
	UNIFORM_VAR( float4 gInstanceData[16], 25 );
UNIFORM_BUFFER_END;

UNIFORM_BUFFER( instance_light_count, 2 )
	UNIFORM_VAR( float2 gLightCounts, 41 );
UNIFORM_BUFFER_END;

#ifdef SKIN
UNIFORM_BUFFER( skin_matrices, 3 )
	UNIFORM_VAR( float4x4 mSkin[32], 42 );
UNIFORM_BUFFER_END;
#endif // SKIN

#if NUM_POINTLIGHTS > 0
UNIFORM_BUFFER( point_light_data, 4 )
	UNIFORM_VAR( PointLight gPLights[16], 170 );
UNIFORM_BUFFER_END;
#endif // NUM_POINTLIGHTS > 0

#if NUM_SPOTLIGHTS > 0
UNIFORM_BUFFER( spot_light_data_vs, 5 )
	UNIFORM_VAR( float4x4 mSpotLight[ NUM_SPOTLIGHTS ], 202 );
UNIFORM_BUFFER_END;

UNIFORM_BUFFER( spot_light_data_ps, 6 )
	UNIFORM_VAR( SpotLight gSLights[ NUM_SPOTLIGHTS ], 210 );
UNIFORM_BUFFER_END;
#endif // NUM_SPOTLIGHTS > 0


#ifndef LIGHT_MULTIPLIER
#define LIGHT_MULTIPLIER 4
#endif


#if VS


#ifdef PARTICLE
void main
(
	float4 ipos : POSITION0,
	float4 icol : COLOR0,
	float4 itex0 : TEXCOORD0,
	out VSOUT vsout
)
{
	float4 viewPos = mul( mWorldView, ipos );
	vsout.pos = mul( mProj, viewPos );
	vsout.viewPos = viewPos;
	vsout.N = float3(0,0,-1);
	vsout.T = float4(1,0,0,1);
	vsout.col = icol;
	vsout.tex0 = itex0;
	vsout.tex1 = itex0;
}
#else // PARTICLE

void main
(
	float3 vpos : POSITION0,
	float3 inrm : NORMAL0,
	float4 itan : TANGENT0,
	float4 icol : COLOR0,
#ifdef SKIN
	float4 iwts : BLENDWEIGHT0,
	BLENDIDX_UINT8_4_TYPE idcs : BLENDINDICES0,
#endif // SKIN
	float4 itex0 : TEXCOORD0,
	float4 itex1 : TEXCOORD1,
	out VSOUT vsout
)
{
	float4 ipos = float4( vpos, 1 );
#ifdef SKIN
	ipos =
		mul( mSkin[ idcs[0] ], ipos ) * iwts[0] +
		mul( mSkin[ idcs[1] ], ipos ) * iwts[1] +
		mul( mSkin[ idcs[2] ], ipos ) * iwts[2] +
		mul( mSkin[ idcs[3] ], ipos ) * iwts[3]
	;
	itan.xyz =
		mul( mSkin[ idcs[0] ], itan.xyz ) * iwts[0] +
		mul( mSkin[ idcs[1] ], itan.xyz ) * iwts[1] +
		mul( mSkin[ idcs[2] ], itan.xyz ) * iwts[2] +
		mul( mSkin[ idcs[3] ], itan.xyz ) * iwts[3]
	;
	inrm =
		mul( mSkin[ idcs[0] ], inrm ) * iwts[0] +
		mul( mSkin[ idcs[1] ], inrm ) * iwts[1] +
		mul( mSkin[ idcs[2] ], inrm ) * iwts[2] +
		mul( mSkin[ idcs[3] ], inrm ) * iwts[3]
	;
#endif // SKIN
	
	float4 worldPos = mul( mWorld, ipos );
	vsout.T = float4( mul( mWorld, float4( itan.xyz, 0 ) ).xyz, itan.w );
	vsout.N = mul( mWorld, float4( inrm, 0 ) ).xyz;
	vsout.col = icol;
	vsout.tex0 = itex0;
	vsout.tex1 = itex1;
	{
__VSCODE__
	}
	vsout.N = mul( mView, float4( vsout.N, 0 ) );
	vsout.T.xyz = mul( mView, float4( vsout.T.xyz, 0 ) );
	float4 viewPos = mul( mView, worldPos );
	vsout.pos = mul( mProj, viewPos );
	vsout.viewPos = viewPos;
#if NUM_SPOTLIGHTS > 0
	vsout.SLPPos0 = mul( mSpotLight[0], worldPos );
#if NUM_SPOTLIGHTS > 1
	vsout.SLPPos1 = mul( mSpotLight[1], worldPos );
#endif // NUM_SPOTLIGHTS > 1
#endif // NUM_SPOTLIGHTS > 0
}

#endif // PARTICLE


#elif PS

NEEDS_TEXTURE_2D(0);
NEEDS_TEXTURE_2D(1);
NEEDS_TEXTURE_2D(2);
NEEDS_TEXTURE_2D(3);
NEEDS_TEXTURE_2D(4);
NEEDS_TEXTURE_2D(5);
NEEDS_TEXTURE_2D(6);
NEEDS_TEXTURE_2D(7);
NEEDS_TEXTURE_2D(8);
NEEDS_TEXTURE_2D(9);
NEEDS_TEXTURE_CUBE(10);
NEEDS_TEXTURE_CUBE(11);
#define InstTex0 Tex8
#define InstTex1 Tex9
#define InstTex2 Tex10
#define InstTex3 Tex11

#ifdef NUM_SPOTLIGHTS
NEEDS_TEXTURE_2D(12);
NEEDS_TEXTURE_SM(13);
NEEDS_TEXTURE_2D(14);
NEEDS_TEXTURE_SM(15);
#endif

void ApplyPointLight( inout float3 totalDiffuse, inout float3 totalSpecular,
	PointLight PL, float3 viewPos, float3 viewNormal, float specPower, float3 rgbmult )
{
	float3 viewDir = normalize( viewPos );
	float3 lightViewPos = PL.vposrad.xyz;
	float3 lightDir = lightViewPos - viewPos;
	float lightDist = length( lightDir );
	lightDir /= lightDist;
	float3 lightColor = PL.colpow.rgb * rgbmult;
	
	float distFactor = pow( 1 - saturate( lightDist / PL.vposrad.w ), PL.colpow.w );
	float NdotL = saturate( dot( viewNormal, lightDir ) );
	
	float RdotV = saturate( dot( reflect( lightDir, viewNormal ), viewDir ) );
	float specAmount = pow( RdotV, specPower ) * sqrt( specPower );
	
	totalDiffuse += lightColor * NdotL * distFactor;
	totalSpecular += lightColor * specAmount * distFactor;
}

bool PostProjCoordToTexDepth( out float3 slpos, float4 coord )
{
	float3 pos = coord.xyz / coord.w;
	slpos = float3( pos.xy * float2(0.5, -0.5) + 0.5, pos.z );
	return dot(step(1-abs( pos ),0),1) <= 0;
}

void main
(
	VSOUT input
	
#if !defined(SHADOW_PASS) || SHADOW_PASS_TO_RT
	ARG_OUT_RT0
#endif
#ifndef SHADOW_PASS
	ARG_OUT_RT1
	ARG_OUT_RT2
#endif // SHADOW_PASS
)
{
	float3 inViewPos = input.viewPos.xyz;
	float3 viewPos = inViewPos;
	float4 projPos = mul( mProj, input.viewPos );
	float3 viewDir = normalize( viewPos );
	float4 inTex0 = input.tex0;
	float4 inTex1 = input.tex1;
	float3 inNormal = input.N;
	float4 inTangentSign = input.T;
	float4 icol = input.col;
	
	inTangentSign.xyz = normalize( inTangentSign.xyz );
	inNormal = normalize( input.N );
	
	float3 T = inTangentSign.xyz;
	float3 B = normalize( cross( inNormal, inTangentSign.xyz ) * inTangentSign.w );
	float3 N = inNormal;
	
	float3x3 TBN = float3x3( T, B, N );
	
	float3 outDiffuseColor = float3( 0.7, 0.7, 0.7 );
	float outOpacity = 1.0;
	float3 outSpecularColor = float3( 0.3, 0.3, 0.3 );
	float outSpecularPower = 32;
	float3 outNormal = inNormal;
	float2 outDistortion = float2( 0, 0 );
	float3 outAmbientDiffuseLight = float3( 0, 0, 0 );
	float3 outAmbientSpecularLight = float3( 0, 0, 0 );
	float3 outEmissiveLight = float3( 0, 0, 0 );
	{
__CODE__
	}
	
#ifdef SHADOW_PASS
#if SHADOW_PASS_TO_RT
	RT0 = float4( projPos.z / projPos.w, 0, 0, 1 );
#endif
#else
	
	outNormal = normalize( outNormal );
	
	float3 refView = reflect( viewDir, outNormal );
	float3 refWorld = mul( mInvView, float4( refView, 0 ) ).xyz;
	
	float3 totalDiffuse = float3(0,0,0);
	float3 totalSpecular = float3(0,0,0);
	
#ifdef BASE_PASS
#if LMODE == 1 || LMODE == 3 // -- static / decal
	float3 LN = mul( mInvView, outNormal );
	float4 contribData = TEXSAMPLE_2D( InstTex1, inTex1.xy );
	totalDiffuse = TEXSAMPLE_2D( InstTex0, inTex1.xy ).rgb *
		lerp( 1, saturate( dot( contribData.xyz * 2 - 1, LN ) ), contribData.w );
#if LMODE == 3 // -- decal
	totalDiffuse *= icol.rgb;
#endif // LMODE == 3
#elif LMODE == 2 // -- dynamic
	float3 LN = mul( mInvView, outNormal );
	float qxp = saturate( LN.x ), qxn = saturate( -LN.x );
	float qyp = saturate( LN.y ), qyn = saturate( -LN.y );
	float qzp = saturate( LN.z ), qzn = saturate( -LN.z );
	totalDiffuse = (
		qxp * gInstanceData[10] + qxn * gInstanceData[11] +
		qyp * gInstanceData[12] + qyn * gInstanceData[13] +
		qzp * gInstanceData[14] + qzn * gInstanceData[15] ) / (qxp+qyp+qzp+qxn+qyn+qzn);
#endif // LMODE
#if defined(DECAL) && LMODE != 3
	totalDiffuse *= icol.rgb;
#endif // defined(DECAL) && LMODE != 3
	totalDiffuse *= LIGHT_MULTIPLIER;
	totalDiffuse += /* gAmbLightColor + */ outAmbientDiffuseLight;
	totalSpecular += outAmbientSpecularLight; // + TEXSAMPLE_CUBE_LOD( InstTex1, refWorld.xzy, 0 ).rgb;
	
	/* DIRECTIONAL LIGHT *--disabled--/
	totalDiffuse += saturate( dot( outNormal, gDirLightDir ) ) * gDirLightColor;
	RdotV = saturate( dot( reflect( gDirLightDir, outNormal ), viewDir ) );
	specAmount = pow( RdotV, outSpecularPower ) * sqrt( outSpecularPower );
	totalSpecular += gDirLightColor * specAmount; */
#endif // BASE_PASS
	
#ifdef DECAL
	outOpacity *= icol.a;
#endif // DECAL
	
#ifdef NUM_POINTLIGHTS
	/* POINT LIGHTS */
	for( int i = 0; i < gLightCounts.x; ++i )
	{
		ApplyPointLight( totalDiffuse, totalSpecular, gPLights[i],
			viewPos, outNormal, outSpecularPower, float3(1,1,1) );
	}
#endif // NUM_POINTLIGHTS
	
#ifdef NUM_SPOTLIGHTS
	/* SPOT LIGHTS */
	if( gLightCounts.y > 0 )
	{
		float3 slpos;
		if( PostProjCoordToTexDepth( slpos, input.SLPPos0 ) )
		{
			SpotLight SL = gSLights[0];
			ApplyPointLight( totalDiffuse, totalSpecular, SL.PL, viewPos, outNormal, outSpecularPower,
				TEXSAMPLE_2D_LOD( Tex12, slpos.xy, 0 ) * SHADOWMAP_2x2( Tex13, SL.shminfo, slpos.xy, slpos.z ) );
		}
	}
	if( gLightCounts.y > 1 )
	{
		float3 slpos;
		if( PostProjCoordToTexDepth( slpos, input.SLPPos1 ) )
		{
			SpotLight SL = gSLights[1];
			ApplyPointLight( totalDiffuse, totalSpecular, SL.PL, viewPos, outNormal, outSpecularPower,
				TEXSAMPLE_2D_LOD( Tex14, slpos.xy, 0 ) * SHADOWMAP_2x2( Tex15, SL.shminfo, slpos.xy, slpos.z ) );
		}
	}
#endif // NUM_SPOTLIGHTS
	
#if LMODE == 0 // -- unlit
	totalDiffuse = float3(1,1,1);
	totalSpecular = float3(0,0,0);
#endif // LMODE == 0
	
	RT0 = float4( totalDiffuse * outDiffuseColor + totalSpecular * outSpecularColor + outEmissiveLight, outOpacity );
	RT1 = float4( outDistortion, 0, outOpacity );
	RT2 = float4( inViewPos.z, 0, 0, 1 );
	
	// modifier addons
#ifdef MOD_BLENDCOLOR
	RT0.rgb = lerp( RT0.rgb,
		gInstanceData[ MOD_BLENDCOLOR ].rgb,
		gInstanceData[ MOD_BLENDCOLOR ].a );
#endif
	
#endif // SHADOW_PASS
}

#endif

