
#if VS
#include "tpl_vs_base"
#elif PS

sampler2D Tex0 : register(s0);
sampler2D Tex1 : register(s1);
sampler2D Tex2 : register(s2);
sampler2D Tex3 : register(s3);
sampler2D Tex4 : register(s4);
sampler2D Tex5 : register(s5);
sampler2D Tex6 : register(s6);
sampler2D Tex7 : register(s7);
sampler2D InstTex0 : register(s8);
samplerCUBE InstTex1 : register(s9);
samplerCUBE InstTex2 : register(s10);
samplerCUBE InstTex3 : register(s11);

float4x4 mInvView : register(c0);
float4x4 mProj : register(c4);
float3 gAmbLightColor : register(c20);
float3 gDirLightDir : register(c21);
float3 gDirLightColor : register(c22);
float4 gLightCounts : register(c23);

#ifdef NUM_POINTLIGHTS
struct PointLight /* size: 2c */
{
	float4 vposrad;
	float4 colpow;
};
PointLight gPLights[ NUM_POINTLIGHTS ] : register(c56); /* :c87 */
#endif

float4 gInstanceData[16] : register(c100); /* :c115 */

void main
(
	float4 inViewPos : TEXCOORD4,
	float4 inTangentSign : TEXCOORD6,
	float3 inNormal : TEXCOORD7,
	float4 icol : COLOR0,
	float4 inTex0 : TEXCOORD0,
	float4 inTex1 : TEXCOORD1,
	out float4 _outColor0 : COLOR0,
	out float4 _outColor1 : COLOR1,
	out float4 _outColor2 : COLOR2
)
{
	float3 viewPos = inViewPos.xyz;
	float4 projPos = mul( mProj, inViewPos );
	float3 viewDir = normalize( viewPos );
	
	inTangentSign.xyz = normalize( inTangentSign.xyz );
	inNormal = normalize( inNormal );
	
	float3 T = inTangentSign.xyz;
	float3 B = normalize( cross( inNormal, inTangentSign.xyz ) * inTangentSign.w );
	float3 N = inNormal;
	
	float3x3 TBN = float3x3( T, B, N );
	
	float3 outDiffuseColor = float3( 0.7, 0.7, 0.7 );
	float outOpacity = 1.0;
	float3 outSpecularColor = float3( 0.3, 0.3, 0.3 );
	float outSpecularPower = 32;
	float3 outNormal = inNormal;
	float2 outDistortion = float2( 0, 0 );
	float3 outAmbientDiffuseLight = float3( 0, 0, 0 );
	float3 outAmbientSpecularLight = float3( 0, 0, 0 );
	float3 outEmissiveLight = float3( 0, 0, 0 );
	{
__CODE__
	}
	outNormal = normalize( outNormal );
	
	float3 refView = reflect( viewDir, outNormal );
	float3 refWorld = mul( mInvView, float4( refView, 0 ) ).xyz;
	
	float3 totalDiffuse = /* gAmbLightColor + */ outAmbientDiffuseLight;
	float3 totalSpecular = outAmbientSpecularLight + texCUBElod( InstTex1, float4( refWorld.xzy, 0 ) ).rgb;
	
	float RdotV, specAmount;
	
	/* DIRECTIONAL LIGHT */
//	totalDiffuse += saturate( dot( outNormal, gDirLightDir ) ) * gDirLightColor;
	RdotV = saturate( dot( reflect( gDirLightDir, outNormal ), viewDir ) );
	specAmount = pow( RdotV, outSpecularPower ) * sqrt( outSpecularPower );
//	totalSpecular += gDirLightColor * specAmount;
	
#ifdef NUM_POINTLIGHTS
	/* POINT LIGHTS */
	for( int i = 0; i < gLightCounts.x; ++i )
	{
		PointLight PL = gPLights[ i ];
		float3 lightViewPos = PL.vposrad.xyz;
		float3 lightDir = lightViewPos - viewPos;
		float lightDist = length( lightDir );
		lightDir /= lightDist;
		float3 lightColor = PL.colpow.rgb;
		
		float distFactor = pow( 1 - saturate( lightDist / PL.vposrad.w ), PL.colpow.w );
		float NdotL = saturate( dot( outNormal, lightDir ) );
		
		RdotV = saturate( dot( reflect( lightDir, outNormal ), viewDir ) );
		specAmount = pow( RdotV, outSpecularPower ) * sqrt( outSpecularPower );
		
		totalDiffuse += lightColor * NdotL * distFactor;
		totalSpecular += lightColor * specAmount * distFactor;
	}
#endif
	
	_outColor0 = float4( totalDiffuse * outDiffuseColor + totalSpecular * outSpecularColor + outEmissiveLight, outOpacity );
	_outColor1 = float4( outDistortion, 0, outOpacity );
	_outColor2 = float4( inViewPos.z, 0, 0, 1 );
}

#endif

