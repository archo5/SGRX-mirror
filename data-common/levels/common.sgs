
//
// Editor helper functions
_G.
{
	EDPI_Pos_Min = -8192,
	EDPI_Pos_Max = 8192,
};
function PropInfo_XForm( eptr )
{
	EE_AddFieldVec3( eptr, "position", "Position", 0, 2, EDPI_Pos_Min, EDPI_Pos_Max );
	EE_AddFieldVec3( eptr, "rotationXYZ", "Rotation", 0, 2, 0, 360 );
	EE_AddFieldVec3( eptr, "scale", "Scale", 1, 2, 0.01, 100 );
}


//
// Entity extension functions
//
function ENTITY( name, inhname )
{
	data = _G[ name ];
	data.
	{
		__inherit = inhname,
		__getindex = mm_getindex_router,
		__setindex = mm_setindex_router
	};
	sym_register( name, data );
	level.entity_types[ name ] = data;
}

Entity.ED_Icon = "editor/icons/default.png";
function PropInfo_Entity( eptr )
{
	EE_AddFieldString( eptr, "name", "Name", "" );
	EE_AddFieldString( eptr, "id", "Global ID", "" );
	PropInfo_XForm( eptr );
}
function Entity.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
}


//
// Entity Editor Extensions
//

global Marker = {};
ENTITY( "Marker", "Entity" );

Marker.ED_Icon = "editor/icons/marker.png";
function Marker.ED_PropInfo( eptr )
{
	EE_AddFieldString( eptr, "name", "Name", "" );
	EE_AddFieldVec3( eptr, "position", "Position", 0, 2, EDPI_Pos_Min, EDPI_Pos_Max );
}
function Marker.EditorDrawWorld()
{
	BR_Reset();
	BR_Col( 0.9, 0.2, 0.1, 0.8 );
	BR_Tick( this.position, 0.1 );
}


global LightSample = {};
ENTITY( "LightSample", "Entity" );

LightSample.ED_Icon = "editor/icons/ltsample.png";
function LightSample.ED_PropInfo( eptr )
{
	EE_AddFieldVec3( eptr, "position", "Position", 0, 2, EDPI_Pos_Min, EDPI_Pos_Max );
}


global SolidBox = {};
ENTITY( "SolidBox", "Entity" );

SolidBox.ED_Icon = "editor/icons/trigger.png";
function SolidBox.ED_PropInfo( eptr )
{
	PropInfo_XForm( eptr );
}
function SolidBox.EditorDrawWorld()
{
	BR_Reset();
	BR_Col( 0.2, 0.3, 0.8, 0.8 );
	BR_AABB( -1, 1, this.transform );
}


global AICover = {};
ENTITY( "AICover", "Entity" );

AICover.ED_Icon = "editor/icons/trigger.png";
function AICover.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
}
function AICover.EditorDrawWorld()
{
	BR_Reset();
	BR_Col( 0.2, 0.3, 0.8, 0.8 );
	BR_AABB( -1, 1, this.transform );
}


global AIRoom = {};
ENTITY( "AIRoom", "Entity" );
function AIRoom.Init()
{
	this.negative = false;
	this.cellSize = 1.0;
}

AIRoom.ED_Icon = "editor/icons/trigger.png";
function AIRoom.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
	EE_AddFieldBool( eptr, "negative", "Is negative (excluding)?", false );
	EE_AddFieldFloat( eptr, "cellSize", "Cell size", 0.5, 2, 0.01, 100 );
}
function AIRoom.EditorDrawWorld()
{
	scale = this.scale;
	mtx = this.transform;
	BR_Reset();
	BR_Col( 0.2, 0.9, 0.8, 0.8 );
	BR_AABB( -1, 1, mtx );
	if( this.negative == false && this.cellSize > 0.01 )
	{
		xcount = floor( scale.x / this.cellSize );
		ycount = floor( scale.y / this.cellSize );
		xncs = this.cellSize / scale.x;
		yncs = this.cellSize / scale.y;
		for( y = 0; y < ycount; ++y )
		{
			for( x = 0; x < xcount; ++x )
			{
				pos = vec3( ( x * 2 - (xcount-1) ) * xncs, ( y * 2 - (ycount-1) ) * yncs, 0 );
				BR_Tick( mtx.transform_pos( pos ), this.cellSize * 0.9 );
			}
		}
	}
}


Mesh.ED_Icon = "editor/icons/mesh.png";
function Mesh.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
	EE_AddFieldMesh( eptr, "mesh", "Mesh" );
	EE_AddFieldBool( eptr, "isStatic", "Is static?", true );
	EE_AddFieldBool( eptr, "visible", "Is visible?", true );
	EE_AddFieldBool( eptr, "solid", "Is solid?", true );
	EE_AddFieldEnumSB( eptr, "lightingMode", "Lighting mode", LM_Static,
		map{ [LM_Unlit] = "Unlit", [LM_Static] = "Static",
		[LM_Dynamic] = "Dynamic", [LM_Decal] = "Decal" } );
	EE_AddFieldFloat( eptr, "lmQuality", "Lightmap quality", 1, 2, 0.01, 100 );
	EE_AddFieldBool( eptr, "castLMS", "[dyn] Cast lightmap shadow", true );
}


Light.ED_Icon = "editor/icons/light.png";
function Light.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
	EE_AddFieldBool( eptr, "isStatic", "Is static?", false );
	EE_AddFieldEnumSB( eptr, "type", "Light type", LIGHT_POINT,
		map{ [LIGHT_POINT] = "Point", [LIGHT_SPOT] = "Spot" } );
	EE_AddFieldBool( eptr, "enabled", "Is enabled?", true );
	EE_AddFieldVec3( eptr, "color", "Color", vec3(0.9,0.7,0.5), 2, 0, 1 );
	EE_AddFieldFloat( eptr, "intensity", "Intensity", 1, 2, -1000, 1000 );
	EE_AddFieldFloat( eptr, "range", "Range", 1, 2, 0, EDPI_Pos_Max );
	EE_AddFieldFloat( eptr, "angle", "[spot] Outer angle", 75, 2, 0, 180 );
	EE_AddFieldFloat( eptr, "innerAngle", "[spot] Inner angle", 0, 2, 0, 180 );
	EE_AddFieldFloat( eptr, "aspect", "[spot] Aspect ratio", 1, 2, 0.01, 100 );
	EE_AddFieldFloat( eptr, "spotCurve", "[spot] Curve", 1, 2, 0.01, 100 );
	EE_AddFieldFloat( eptr, "radius", "Light radius", 0.1, 2, 0, 100 );
	EE_AddFieldBool( eptr, "hasShadows", "Has shadows?", true );
	EE_AddFieldTex( eptr, "cookieTexture", "[spot] Cookie texture",
		"textures/cookies/default.png" );
	EE_AddFieldFloat( eptr, "flareSize", "Flare size", 0, 2, 0, 100 );
	EE_AddFieldVec3( eptr, "flareOffset", "Flare offset", 0, 2, 0, 100 );
}


//
// Mesh Array
//

global MeshArray = {};
ENTITY( "MeshArray", "Entity" );
function MeshArray.Init()
{
	this._data.
	{
		offset = vec3(0),
		count = 1,
		limit = 100,
		
		mesh = null,
		solid = true,
		lightingMode = LM_Static,
		lmQuality = 1.0,
		castLMS = true,
		
		_entities = [],
	};
	this._ReadjustParts();
}
function MeshArray._ReconfigEntity( e, i )
{
	e.position = this.offset * i;
	e.mesh = this.mesh;
	e.solid = this.solid;
	e.lightingMode = this.lightingMode;
	e.lmQuality = this.lmQuality;
	e.castLMS = this.castLMS;
}
function MeshArray._ReadjustParts( norec )
{
	// remove extra entities
	while( this._entities.size > this.count )
	{
		level.DestroyEntity( this._entities.last );
		this._entities.pop();
	}
	
	if( !norec )
	{
		// reconfigure existing entities
		for( i = 0; i < this._entities.size; ++i )
			this._ReconfigEntity( this._entities[ i ], i );
	}
	
	// add new entities
	while( this._entities.size < this.count )
	{
		e = level.CreateEntity( "Mesh" );
		this._ReconfigEntity( e, this._entities.size );
		this._entities.push( e );
	}
}
function MeshArray.__set_offset( off )
{
	if( typeof( off ) != "vec3" )
		ERROR( "wrong type for 'vec3 offset'" );
	this._data.offset = off;
	this._ReadjustParts( true );
}
function MeshArray.__set_count( cnt )
{
	cnt = toint(cnt);
	if( cnt < 0 || cnt > this.limit )
		ERROR( "count must be >= 0 and <= limit (" $ this.limit $ ")" );
	this._data.count = cnt;
	this._ReadjustParts( true );
}
function MeshArray.__set_mesh( m ){ this._data.mesh = m; this._ReadjustParts(); }
function MeshArray.__set_solid( s ){ this._data.solid = s; this._ReadjustParts(); }
function MeshArray.__set_lightingMode( lm ){ this._data.lightingMode = lm; this._ReadjustParts(); }
function MeshArray.__set_lmQuality( q ){ this._data.lmQuality = q; this._ReadjustParts(); }
function MeshArray.__set_castLMS( c ){ this._data.castLMS = c; this._ReadjustParts(); }

MeshArray.ED_Icon = "editor/icons/mesharray.png";
function MeshArray.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
	EE_AddFieldVec3( eptr, "offset", "Offset", vec3(0,0,1), 2, -100, 100 );
	EE_AddFieldInt( eptr, "count", "Count", 1, 0, 100 );
	EE_AddFieldMesh( eptr, "mesh", "Mesh" );
	EE_AddFieldBool( eptr, "solid", "Is solid?", true );
	EE_AddFieldEnumSB( eptr, "lightingMode", "Lighting mode", LM_Static,
		map{ [LM_Unlit] = "Unlit", [LM_Static] = "Static",
		[LM_Dynamic] = "Dynamic", [LM_Decal] = "Decal" } );
	EE_AddFieldFloat( eptr, "lmQuality", "Lightmap quality", 1, 2, 0.01, 100 );
	EE_AddFieldBool( eptr, "castLMS", "[dyn] Cast lightmap shadow", true );
}


//
// Trigger Entity Core
//
global Trigger = {};

function Trigger.Init()
{
	this.
	{
		func = null,
		funcOut = null,
		once = true,
		done = false,
		currState = false,
		lastState = false,
		mask = IEST_Player,
	};
}

function Trigger.Invoke( newstate )
{
	newstate = tobool( newstate );
	curfn = if( newstate, this.func, this.funcOut );
	if( curfn !== null )
	{
		curfn( newstate );
	}
}

function Trigger.UpdateState( newstate )
{
	if( this.currState != newstate && !this.done )
	{
		this.currState = newstate;
		this.Invoke( newstate );
		if( this.once && newstate == this.lastState ) // once on, once off
			this.done = true;
	}
}

function Trigger.SetupTrigger( once, fn, fnout )
{
	this.done = false;
	this.once = tobool( once );
	this.func = fn;
	if( typeof(fnout) == "bool" )
		this.funcOut = if( fnout, fn, null );
	else
		this.funcOut = fnout ?? fn;
}


//
// Trigger Entity - Box
//
global BoxTrigger = clone( Trigger );
ENTITY( "BoxTrigger", "Entity" );

BoxTrigger.ED_Icon = "editor/icons/trigger.png";
function BoxTrigger.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
}

function BoxTrigger.Update( dt )
{
	this.UpdateState( level.QueryOBB( null, this.mask, this.transform ) );
}


//
// Trigger Entity - Sphere
//
global SphereTrigger = clone( Trigger );
ENTITY( "SphereTrigger", "Entity" );

function SphereTrigger.Init()
{
	this!Trigger.Init();
	this.radius = 1;
}

function SphereTrigger.Update( dt )
{
	this.UpdateState( level.QuerySphere( null, this.mask, this.position, this.radius ) );
}


//
// Door Entity Core
//
global DoorCore = clone( Trigger );

// callbacks
function DoorCore.OnDoorMoveStart(){}
function DoorCore.OnDoorMoveEnd(){}
function DoorCore.OnDoorMove(){} // physics
function DoorCore.OnDoorPreRender( bf ){} // transform

function DoorCore.Init()
{
	this!Trigger.Init();
	
	this.
	{
		openPosition = vec3(0),
		openRotation = quat(),
		closedPosition = vec3(0),
		closedRotation = quat(),
		openingTime = 1,
		initialState = false,
		targetState = false,
		openState = 0.0,
		openTarget = 0.0,
	};
	
	this._pPos = this._cPos = this.GetCurrentPosition();
	this._pRot = this._cRot = this.GetCurrentRotation();
	
	this.OnDoorMove();
	this.OnDoorPreRender( 1.0 );
}

function DoorCore.Open(){ this.targetState = true; }
function DoorCore.Close(){ this.targetState = false; }
function DoorCore.Toggle(){ this.targetState = !this.targetState; }

function DoorCore.GetCurrentPosition()
{
	return lerp( this.closedPosition, this.openPosition, this.openState );
}

function DoorCore.GetCurrentRotation()
{
	return lerp( this.closedRotation, this.openRotation, this.openState );
}

function DoorCore.GetInterpolatedPosition( bf )
{
	return lerp( this._pPos, this._cPos, bf );
}

function DoorCore.GetInterpolatedRotation( bf )
{
	return lerp( this._pRot, this._cRot, bf );
}

function DoorCore.FixedUpdate( dt )
{
	if( this.openState != this.openTarget )
	{
		df = this.openTarget - this.openState;
		df /= this.openingTime;
		df_len = abs( df );
		df_dir = sign( df );
		if( this.openingTime > 0 )
		{
			df_len /= this.openingTime;
			if( df_len > dt )
				df_len = dt;
		}
		else
			df_len = 1;
		this.openState = clamp( this.openState + df_len * df_dir, 0.0, 1.0 );
		
		this.OnDoorMove();
		if( this.openState == this.openTarget )
		{
			this.UpdateState( this.openTarget );
			this.OnDoorMoveEnd();
		}
	}
	else if( this.openTarget != toreal( this.targetState ) )
	{
		this.openTarget = toreal( this.targetState );
		this.OnDoorMoveStart();
	}
	
	this._pPos = this._cPos;
	this._pRot = this._cRot;
	this._cPos = this.GetCurrentPosition();
	this._cRot = this.GetCurrentRotation();
}

function DoorCore.Update( dt, bf )
{
	this.OnDoorPreRender( bf );
}

