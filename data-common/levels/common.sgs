
function lerp( a, b, s ){ return a * ( 1 - s ) + b * s; }
function sign( x ){ return if( x != 0, if( x > 0, 1, -1 ), 0 ); }

//
// Editor helper functions
_G.
{
	EDPI_Pos_Min = -8192,
	EDPI_Pos_Max = 8192,
};
function PropInfo_XForm( eptr )
{
	EE_AddFieldVec3( eptr, "position", "Position", 0, 2, EDPI_Pos_Min, EDPI_Pos_Max );
	EE_AddFieldVec3( eptr, "rotationXYZ", "Rotation", 0, 2, 0, 360 );
	EE_AddFieldVec3( eptr, "scale", "Scale", 1, 2, 0.01, 100 );
}


//
// Entity extension functions
//
function ENTITY( name, inhname )
{
	data = _G[ name ];
	data.
	{
		__inherit = inhname,
		__getindex = mm_getindex_router,
		__setindex = mm_setindex_router
	};
	sym_register( name, data );
	level.entity_types[ name ] = data;
}

Entity.ED_Icon = "editor/icons/default.png";
function PropInfo_Entity( eptr )
{
	EE_AddFieldString( eptr, "name", "Name", "" );
	EE_AddFieldString( eptr, "id", "Global ID", "" );
	PropInfo_XForm( eptr );
}
function Entity.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
}


//
// Entity Editor Extensions
//

global Marker = {};
ENTITY( "Marker", "Entity" );

Marker.ED_Icon = "editor/icons/marker.png";
function Marker.ED_PropInfo( eptr )
{
	EE_AddFieldString( eptr, "name", "Name", "" );
	EE_AddFieldVec3( eptr, "position", "Position", 0, 2, EDPI_Pos_Min, EDPI_Pos_Max );
}
function Marker.EditorDrawWorld()
{
	BR_Reset();
	BR_Col( 0.9, 0.2, 0.1, 0.8 );
	BR_Tick( this.position, 0.1 );
}


global LightSample = {};
ENTITY( "LightSample", "Entity" );

LightSample.ED_Icon = "editor/icons/ltsample.png";
function LightSample.ED_PropInfo( eptr )
{
	EE_AddFieldVec3( eptr, "position", "Position", 0, 2, EDPI_Pos_Min, EDPI_Pos_Max );
}


global MapLayer = {};
ENTITY( "MapLayer", "Entity" );

MapLayer.ED_Icon = "editor/icons/marker.png";
function MapLayer.ED_PropInfo( eptr )
{
	EE_AddFieldVec3( eptr, "position", "Position", 0, 2, EDPI_Pos_Min, EDPI_Pos_Max );
}


global SolidBox = {};
ENTITY( "SolidBox", "Entity" );

SolidBox.ED_Icon = "editor/icons/trigger.png";
function SolidBox.ED_PropInfo( eptr )
{
	PropInfo_XForm( eptr );
}
function SolidBox.EditorDrawWorld()
{
	BR_Reset();
	BR_Col( 0.2, 0.3, 0.8, 0.8 );
	BR_AABB( -1, 1, this.transform );
}


global AICover = {};
ENTITY( "AICover", "Entity" );

AICover.ED_Icon = "editor/icons/trigger.png";
function AICover.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
	EE_AddFieldBool( eptr, "negative", "Is negative (excluding)?", false );
}
function AICover.EditorDrawWorld()
{
	BR_Reset();
	BR_Col( 0.2, 0.3, 0.8, 0.8 );
	BR_AABB( -1, 1, this.transform );
}


global AIPathArea = {};
ENTITY( "AIPathArea", "Entity" );

AIPathArea.ED_Icon = "editor/icons/trigger.png";
function AIPathArea.ED_PropInfo( eptr )
{
	PropInfo_XForm( eptr );
}
function AIPathArea.EditorDrawWorld()
{
	BR_Reset();
	BR_Col( 0.2, 0.6, 0.8, 0.8 );
	BR_AABB( -1, 1, this.transform );
}


global AIRoom = {};
ENTITY( "AIRoom", "Entity" );
function AIRoom.Init()
{
	this.negative = false;
	this.cellSize = 1.0;
}

AIRoom.ED_Icon = "editor/icons/trigger.png";
function AIRoom.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
	EE_AddFieldBool( eptr, "negative", "Is negative (excluding)?", false );
	EE_AddFieldFloat( eptr, "cellSize", "Cell size", 0.5, 2, 0.01, 100 );
}
function AIRoom.EditorDrawWorld()
{
	scale = this.scale;
	mtx = this.transform;
	BR_Reset();
	BR_Col( 0.2, 0.9, 0.8, 0.8 );
	BR_AABB( -1, 1, mtx );
	if( this.negative == false && this.cellSize > 0.01 )
	{
		xcount = floor( scale.x / this.cellSize );
		ycount = floor( scale.y / this.cellSize );
		xncs = this.cellSize / scale.x;
		yncs = this.cellSize / scale.y;
		for( y = 0; y < ycount; ++y )
		{
			for( x = 0; x < xcount; ++x )
			{
				pos = vec3( ( x * 2 - (xcount-1) ) * xncs, ( y * 2 - (ycount-1) ) * yncs, 0 );
				BR_Tick( mtx.transform_pos( pos ), this.cellSize * 0.9 );
			}
		}
	}
}


function ParticleFX.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
	EE_AddFieldPartSys( eptr, "particleSystemPath", "Particle system path", "psys/dustarea.psy" );
	EE_AddFieldSound( eptr, "soundEvent", "Sound event", "" );
	EE_AddFieldBool( eptr, "enabled", "Playing", true );
}


Mesh.ED_Icon = "editor/icons/mesh.png";
function Mesh.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
	EE_AddFieldMesh( eptr, "mesh", "Mesh" );
	EE_AddFieldBool( eptr, "isStatic", "Is static?", true );
	EE_AddFieldBool( eptr, "visible", "Is visible?", true );
	EE_AddFieldBool( eptr, "solid", "Is solid?", true );
	EE_AddFieldEnumSB( eptr, "lightingMode", "Lighting mode", LM_Static,
		map{ [LM_Unlit] = "Unlit", [LM_Static] = "Static",
		[LM_Dynamic] = "Dynamic", [LM_Decal] = "Decal" } );
	EE_AddFieldFloat( eptr, "lmQuality", "Lightmap quality", 1, 2, 0.01, 100 );
	EE_AddFieldBool( eptr, "castLMS", "[dyn] Cast lightmap shadow", true );
}


Light.ED_Icon = "editor/icons/light.png";
function Light.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
	EE_AddFieldBool( eptr, "isStatic", "Is static?", false );
	EE_AddFieldEnumSB( eptr, "type", "Light type", LIGHT_POINT,
		map{ [LIGHT_POINT] = "Point", [LIGHT_SPOT] = "Spot" } );
	EE_AddFieldBool( eptr, "enabled", "Is enabled?", true );
	EE_AddFieldVec3( eptr, "color", "Color", vec3(0.9,0.7,0.5), 2, 0, 1 );
	EE_AddFieldFloat( eptr, "intensity", "Intensity", 1, 2, -1000, 1000 );
	EE_AddFieldFloat( eptr, "range", "Range", 1, 2, 0, EDPI_Pos_Max );
	EE_AddFieldFloat( eptr, "power", "Power", 2, 2, 0.01, 100 );
	EE_AddFieldFloat( eptr, "angle", "[spot] Outer angle", 75, 2, 0, 180 );
	EE_AddFieldFloat( eptr, "innerAngle", "[spot] Inner angle", 0, 2, 0, 180 );
	EE_AddFieldFloat( eptr, "aspect", "[spot] Aspect ratio", 1, 2, 0.01, 100 );
	EE_AddFieldFloat( eptr, "spotCurve", "[spot] Curve", 1, 2, 0.01, 100 );
	EE_AddFieldFloat( eptr, "lightRadius", "Light radius", 0.1, 2, 0, 100 );
	EE_AddFieldBool( eptr, "hasShadows", "Has shadows?", true );
	EE_AddFieldTex( eptr, "cookieTexture", "[spot] Cookie texture",
		"textures/cookies/default.png" );
	EE_AddFieldFloat( eptr, "flareSize", "Flare size", 0, 2, 0, 100 );
	EE_AddFieldVec3( eptr, "flareOffset", "Flare offset", 0, 2, -100, 100 );
}
function Light.EditorDrawWorld()
{
	p = this.position;
	r1 = this.range;
	r2 = pow( 0.5, this.power ) * this.range;
	BR_Reset();
	if( this.type == LIGHT_SPOT )
	{
		d = this.transform.transform_normal( vec3(0,0,-1) ).normalized;
		u = this.transform.transform_normal( vec3(0,-1,0) ).normalized;
		BR_Col( 0.9, 0.8, 0.1, 0.5 );
		BR_ConeOutline( p, d, u, r1, this.angle, 32 );
		BR_Col( 0.9, 0.5, 0.1, 0.5 );
		BR_ConeOutline( p, d, u, r2, this.angle, 32 );
	}
	else
	{
		BR_Col( 0.9, 0.8, 0.1, 0.5 );
		BR_SphereOutline( p, r1, 64 );
		BR_Col( 0.9, 0.5, 0.1, 0.5 );
		BR_SphereOutline( p, r2, 32 );
	}
	
	BR_Col( 0.9, 0.8, 0.1, 1 );
	BR_Tick( this.LocalToWorld( this.flareOffset ), 0.1 );
}


RigidBody.ED_Icon = "editor/icons/rigid_body.png";
function RigidBody.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
	EE_AddFieldFloat( eptr, "friction", "Friction", 0.9, 2, 0, 1 );
	EE_AddFieldFloat( eptr, "restitution", "Restitution", 0.1, 2, 0, 1 );
	EE_AddFieldFloat( eptr, "mass", "Mass", 0, 2, 0, 10000 );
	EE_AddFieldFloat( eptr, "linearDamping", "Linear damping", 0.1, 2, 0, 1 );
	EE_AddFieldFloat( eptr, "angularDamping", "Angular damping", 0.1, 2, 0, 1 );
	EE_AddFieldBool( eptr, "kinematic", "Is kinematic?", true );
	EE_AddFieldBool( eptr, "canSleep", "Can sleep?", true );
	EE_AddFieldBool( eptr, "enabled", "Is enabled?", true );
	EE_AddFieldInt( eptr, "group", "Group", 1, 0, 0xffff );
	EE_AddFieldInt( eptr, "mask", "Mask", 0xffff, 0, 0xffff );
	EE_AddFieldEnumSB( eptr, "shapeType", "Shape type", ShapeType_AABB,
		map{
			[ShapeType_AABB] = "AABB",
			[ShapeType_Box] = "Box",
			[ShapeType_Sphere] = "Sphere",
			[ShapeType_Cylinder] = "Cylinder",
			[ShapeType_Capsule] = "Capsule",
			[ShapeType_Mesh] = "Mesh",
		});
	EE_AddFieldFloat( eptr, "shapeRadius", "Radius [sph/cap]", 0.5, 2, 0.01, 1000 );
	EE_AddFieldFloat( eptr, "shapeHeight", "Height [cap]", 1, 2, 0.01, 1000 );
	EE_AddFieldVec3( eptr, "shapeExtents", "Extents [cyl/box/aabb]", 0.5, 2, -1000, 1000 );
	EE_AddFieldVec3( eptr, "shapeMinExtents", "Min. extents [aabb]", -0.5, 2, -1000, 1000 );
	EE_AddFieldMesh( eptr, "shapeMesh", "Mesh" );
}
function RigidBody.EditorDrawWorld()
{
	BR_Reset();
	BR_Col( 0.1, 0.2, 0.8, 1 );
	BR_AABB( this.shapeMinExtents, this.shapeExtents, this.transform );
}


function ReflectionPlane.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
}
function ReflectionPlane.EditorDrawWorld()
{
	BR_Reset();
	BR_Col( 0.2, 0.8, 0.9, 0.8 );
	BR_AABB( vec3(-1,-1,0), vec3(1,1,0), this.transform );
}


//
// Mesh Array
//

global MeshArray = {};
ENTITY( "MeshArray", "Entity" );
function MeshArray.Init()
{
	this._data.
	{
		offset = vec3(0),
		count = 1,
		limit = 100,
		
		mesh = null,
		solid = true,
		lightingMode = LM_Static,
		lmQuality = 1.0,
		castLMS = true,
		
		_entities = [],
	};
	this._ReadjustParts();
}
function MeshArray.OnDestroy()
{
	for( i = 0; i < this._entities.size; ++i )
		level.DestroyEntity( this._entities[ i ] );
}
function MeshArray.OnIDUpdate()
{
	for( i = 0; i < this._entities.size; ++i )
		this._entities[ i ].id = this.id $ "#" $ i;
}
function MeshArray._ReconfigEntity( e, i )
{
	e.localPosition = this.offset * i;
	e.mesh = this.mesh;
	e.solid = this.solid;
	e.lightingMode = this.lightingMode;
	e.lmQuality = this.lmQuality;
	e.castLMS = this.castLMS;
	e.parent = this;
}
function MeshArray._ReadjustParts( norec )
{
	// remove extra entities
	while( this._entities.size > this.count )
	{
		level.DestroyEntity( this._entities.last );
		this._entities.pop();
	}
	
	if( !norec )
	{
		// reconfigure existing entities
		for( i = 0; i < this._entities.size; ++i )
			this._ReconfigEntity( this._entities[ i ], i );
	}
	
	// add new entities
	while( this._entities.size < this.count )
	{
		e = level.CreateEntity( "Mesh" );
		e.id = this.id $ "#" $ this._entities.size;
		this._ReconfigEntity( e, this._entities.size );
		this._entities.push( e );
	}
}
function MeshArray.__set_offset( off )
{
	if( typeof( off ) != "vec3" )
		ERROR( "wrong type for 'vec3 offset'" );
	this._data.offset = off;
	this._ReadjustParts();
}
function MeshArray.__set_count( cnt )
{
	cnt = toint(cnt);
	if( cnt < 0 || cnt > this.limit )
		ERROR( "count must be >= 0 and <= limit (" $ this.limit $ ")" );
	this._data.count = cnt;
	this._ReadjustParts( true );
}
function MeshArray.OnTransformUpdate(){ this._ReadjustParts(); }
function MeshArray.__set_mesh( m ){ this._data.mesh = m; this._ReadjustParts(); }
function MeshArray.__set_solid( s ){ this._data.solid = s; this._ReadjustParts(); }
function MeshArray.__set_lightingMode( lm ){ this._data.lightingMode = lm; this._ReadjustParts(); }
function MeshArray.__set_lmQuality( q ){ this._data.lmQuality = q; this._ReadjustParts(); }
function MeshArray.__set_castLMS( c ){ this._data.castLMS = c; this._ReadjustParts(); }

MeshArray.ED_Icon = "editor/icons/mesharray.png";
function MeshArray.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
	EE_AddFieldVec3( eptr, "offset", "Offset", vec3(0,0,1), 2, -100, 100 );
	EE_AddFieldInt( eptr, "count", "Count", 1, 0, 100 );
	EE_AddFieldMesh( eptr, "mesh", "Mesh" );
	EE_AddFieldBool( eptr, "solid", "Is solid?", true );
	EE_AddFieldEnumSB( eptr, "lightingMode", "Lighting mode", LM_Static,
		map{ [LM_Unlit] = "Unlit", [LM_Static] = "Static",
		[LM_Dynamic] = "Dynamic", [LM_Decal] = "Decal" } );
	EE_AddFieldFloat( eptr, "lmQuality", "Lightmap quality", 1, 2, 0.01, 100 );
	EE_AddFieldBool( eptr, "castLMS", "[dyn] Cast lightmap shadow", true );
}


//
// Trigger Entity Core
//
global Trigger = {};

function Trigger.Init()
{
	this.
	{
		func = null,
		funcOut = null,
		once = true,
		done = false,
		currState = false,
		lastState = false,
		mask = IEST_Player,
	};
}

function Trigger.Invoke( newstate )
{
	newstate = tobool( newstate );
	curfn = if( newstate, this.func, this.funcOut );
	if( curfn !== null )
	{
		curfn( newstate );
	}
}

function Trigger.UpdateState( newstate )
{
	if( this.once < 0 || ( this.currState != newstate && !this.done ) )
	{
		this.currState = newstate;
		this.Invoke( newstate );
		if( this.once > 0 && newstate == this.lastState ) // once on, once off
			this.done = true;
	}
}

function Trigger.SetupTrigger( once, fn, fnout )
{
	this.done = false;
	this.once = toint( once );
	this.func = fn;
	if( typeof(fnout) == "bool" )
		this.funcOut = if( fnout, fn, null );
	else
		this.funcOut = fnout;
}


//
// Trigger Entity - Box
//
global BoxTrigger = clone( Trigger );
ENTITY( "BoxTrigger", "Entity" );

BoxTrigger.ED_Icon = "editor/icons/trigger.png";
function BoxTrigger.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
}
function BoxTrigger.EditorDrawWorld()
{
	BR_Reset();
	BR_Col( 0.1, 0.4, 0.9 );
	BR_AABB( -1, 1, this.transform );
}

function BoxTrigger.Update( dt )
{
	this.UpdateState( level.QueryOBB( null, this.mask, this.transform ) );
}


//
// Trigger Entity - Sphere
//
global SphereTrigger = clone( Trigger );
ENTITY( "SphereTrigger", "Entity" );

function SphereTrigger.Init()
{
	this!Trigger.Init();
	this.radius = 1;
}

function SphereTrigger.Update( dt )
{
	this.UpdateState( level.QuerySphere( null, this.mask, this.position, this.radius ) );
}


//
// Door Entity Core
//
global DoorCore = clone( Trigger );

// callbacks
function DoorCore.OnDoorMoveStart(){}
function DoorCore.OnDoorMoveEnd(){}
function DoorCore.OnDoorMove(){} // physics
function DoorCore.OnDoorPreRender( bf ){} // transform

function DoorCore.Init()
{
	this!Trigger.Init();
	
	this._data.
	{
		openPosition = vec3(0),
		openRotation = quat(),
		closedPosition = vec3(0),
		closedRotation = quat(),
		openingTime = 1,
		targetState = false,
		openState = 0.0,
		openTarget = 0.0,
		ev_finished = event(true),
	};
	
	this._OnReposition();
}

function DoorCore._OnReposition()
{
	this._pPos = this._cPos = this.GetCurrentPosition();
	this._pRot = this._cRot = this.GetCurrentRotation();
	this.OnDoorMove();
	this.OnDoorPreRender( 1.0 );
}

function DoorCore.__get_initialState(){ return this.openState; }
function DoorCore.__set_initialState( v )
{
	v = toreal( v );
	this.targetState = v > 0.5;
	this.openState = v;
	this.openTarget = v;
	this._OnReposition();
}

function DoorCore.Open()
{
	this.targetState = true;
	this.ev_finished.signaled = false;
}
function DoorCore.Close()
{
	this.targetState = false;
	this.ev_finished.signaled = false;
}
function DoorCore.Toggle()
{
	this.targetState = !this.targetState;
	this.ev_finished.signaled = false;
}

function DoorCore.GetCurrentPosition()
{
	return lerp( this.closedPosition, this.openPosition, this.openState );
}

function DoorCore.GetCurrentRotation()
{
	return quat_slerp( this.closedRotation, this.openRotation, this.openState );
}

function DoorCore.GetInterpolatedPosition( bf )
{
	return lerp( this._pPos, this._cPos, bf );
}

function DoorCore.GetInterpolatedRotation( bf )
{
	return quat_slerp( this._pRot, this._cRot, bf );
}

function DoorCore.PrePhysicsFixedUpdate( dt )
{
	if( this.openState != this.openTarget )
	{
		df = this.openTarget - this.openState;
		df_len = abs( df );
		df_dir = sign( df );
		if( this.openingTime > 0 )
		{
			dtot = dt / this.openingTime;
			if( df_len > dtot )
				df_len = dtot;
		}
		else
			df_len = 1;
		df_len += 0.001;
		this.openState = clamp( this.openState + df_len * df_dir, 0.0, 1.0 );
		
		this.OnDoorMove();
		if( this.openState == this.openTarget )
		{
			this.UpdateState( this.openTarget );
			this.OnDoorMoveEnd();
		}
	}
	else if( this.openTarget != toreal( this.targetState ) )
	{
		this.openTarget = toreal( this.targetState );
		this.OnDoorMoveStart();
	}
	this.ev_finished.signaled = this.openState == this.openTarget;
	
	this._pPos = this._cPos;
	this._pRot = this._cRot;
	this._cPos = this.GetCurrentPosition();
	this._cRot = this.GetCurrentRotation();
}

function DoorCore.Update( dt, bf )
{
	this.OnDoorPreRender( bf );
}


global BasicDoor = clone( DoorCore );
ENTITY( "BasicDoor", "Entity" );

function BasicDoor.Init()
{
	this!DoorCore.Init();
	
	this.
	{
		meshEnt = level.CreateEntity( "Mesh" ).
		{
			name = "door",
			parent = this,
			isStatic = false,
			lightingMode = LM_Dynamic,
			solid = false,
		},
		bodyEnt = level.CreateEntity( "RigidBody" ).
		{
			name = "door",
			parent = this,
			shapeType = ShapeType_AABB,
		//	kinematic = true,
		},
	};
}

function BasicDoor.OnDestroy()
{
	level.DestroyEntity( this.meshEnt );
	level.DestroyEntity( this.bodyEnt );
}

function BasicDoor.__get_mesh(){ return this.meshEnt.mesh; }
function BasicDoor.__set_mesh( v )
{
	this.meshEnt.mesh = v;
	md = this.meshEnt.meshData;
	if( md !== null )
	{
		this.bodyEnt.shapeExtents = md.boundsMax;
		this.bodyEnt.shapeMinExtents = md.boundsMin;
		this.bodyEnt.shapeMesh = md;
	}
}
function BasicDoor.__get_castLMS(){ return this.meshEnt.castLMS; }
function BasicDoor.__set_castLMS( v ){ this.meshEnt.castLMS = v; }
function BasicDoor.__get_meshCollisions(){ return this.bodyEnt.shapeType == ShapeType_Mesh; }
function BasicDoor.__set_meshCollisions( v ){ this.bodyEnt.shapeType = if( v, ShapeType_Mesh, ShapeType_AABB ); }
function BasicDoor.__set_closedPosition( v ){ this._data.closedPosition = v; this._OnReposition(); }
function BasicDoor.__set_openPosition( v ){ this._data.openPosition = v; this._OnReposition(); }
function BasicDoor.__get_closedRotationXYZ(){ return quat2euler( this.closedRotation ); }
function BasicDoor.__set_closedRotationXYZ( v ){ this.closedRotation = euler2quat( v ); this._OnReposition(); }
function BasicDoor.__get_openRotationXYZ(){ return quat2euler( this.openRotation ); }
function BasicDoor.__set_openRotationXYZ( v ){ this.openRotation = euler2quat( v ); this._OnReposition(); }

function BasicDoor._MoveDoor( p, r )
{
	for( i = 0, cc = this.childCount; i < cc; ++i )
	{
		ch = this.GetChild( i );
		if( ch.name != "door" )
			continue;
		ch.localPosition = p;
		ch.localRotation = r;
	}
}

function BasicDoor.OnDoorMove()
{
	this._MoveDoor(
		this.GetCurrentPosition(),
		this.GetCurrentRotation()
	);
}

function BasicDoor.OnDoorPreRender( bf )
{
	this._MoveDoor(
		this.GetInterpolatedPosition( bf ),
		this.GetInterpolatedRotation( bf )
	);
}

function BasicDoor.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
	EE_AddFieldMesh( eptr, "mesh", "Mesh" );
	EE_AddFieldVec3( eptr, "closedPosition", "Closed position", vec3(0,0,0), 2, -100, 100 );
	EE_AddFieldVec3( eptr, "closedRotationXYZ", "Closed rotation", vec3(0,0,0), 2, 0, 360 );
	EE_AddFieldVec3( eptr, "openPosition", "Open position", vec3(0,0,1), 2, -100, 100 );
	EE_AddFieldVec3( eptr, "openRotationXYZ", "Open rotation", vec3(0,0,0), 2, 0, 360 );
	EE_AddFieldFloat( eptr, "openingTime", "Opening time", 1, 2, 0.01, 100 );
	EE_AddFieldFloat( eptr, "initialState", "Initial openness", 0, 2, 0, 1 );
	EE_AddFieldBool( eptr, "castLMS", "[dyn] Cast lightmap shadow", true );
	EE_AddFieldBool( eptr, "meshCollisions", "Mesh collisions", false );
}

function BasicDoor.EditorDrawWorld()
{
	BR_Reset();
	BR_Col( 0.6, 0.6, 0.1, 1 );
	BR_AABB( this.bodyEnt.shapeMinExtents,
		this.bodyEnt.shapeExtents,
		this.bodyEnt.transform );
	BR_Col( 0.8, 0.3, 0.1, 1 );
	BR_Tick( this.LocalToWorld( this.closedPosition ), 0.1 );
	BR_Col( 0.3, 0.8, 0.1, 1 );
	BR_Tick( this.LocalToWorld( this.openPosition ), 0.1 );
}

