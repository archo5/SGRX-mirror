
//
// Entity extension function
//
function CreateEntityExt( iface_name, base )
{
	E = level.CreateEntity( base, null );
	E._data = {};
	iface = _G[ iface_name ];
	omo = metaobj_get( E );
	iomo = metaobj_get( iface );
	if( iomo !== null && iomo !== omo )
		ERROR( "redefining metaobject for \"" $ iface_name $ "\"" );
	metaobj_set( iface, omo );
	metaobj_set( E, iface );
	metamethods_enable( E, true );
	return E;
}


//
// Trigger Entity Core
//
global Trigger = { __getindex = mm_getindex_router, __setindex = mm_setindex_router };

function Trigger.Init()
{
	this.
	{
		func = null,
		funcOut = null,
		once = true,
		done = false,
		currState = false,
		lastState = false,
		mask = IEST_Player,
	};
}

function Trigger.Invoke( newstate )
{
	newstate = tobool( newstate );
	curfn = if( newstate, this.func, this.funcOut );
	if( curfn !== null )
	{
		curfn( newstate );
	}
}

function Trigger.UpdateState( newstate )
{
	if( this.currState != newstate && !this.done )
	{
		this.currState = newstate;
		this.Invoke( newstate );
		if( this.once && newstate == this.lastState ) // once on, once off
			this.done = true;
	}
}

function Trigger.SetupTrigger( once, fn, fnout )
{
	this.done = false;
	this.once = tobool( once );
	this.func = fn;
	if( typeof(fnout) == "bool" )
		this.funcOut = if( fnout, fn, null );
	else
		this.funcOut = fnout ?? fn;
}


//
// Trigger Entity - Box
//
global BoxTrigger = clone( Trigger );

function BoxTrigger.Update( dt )
{
	this.UpdateState( level.infoEmitters.QueryBB( this.transform, this.mask ) );
}

function ENTCREATE_BoxTrigger()
{
	E = CreateEntityExt( "BoxTrigger", "Entity" );
	E.Init();
	return E;
}


//
// Trigger Entity - Sphere
//
global SphereTrigger = clone( Trigger );

function SphereTrigger.Init()
{
	this!Trigger.Init();
	this.radius = 1;
}

function SphereTrigger.Update( dt )
{
	this.UpdateState( level.infoEmitters.QuerySphereAny( this.position, this.radius, this.mask ) );
}

function ENTCREATE_SphereTrigger()
{
	E = CreateEntityExt( "SphereTrigger", "Entity" );
	E.Init();
	return E;
}


//
// Door Entity Core
//
global DoorCore = clone( Trigger );

// callbacks
function DoorCore.OnDoorMoveStart(){}
function DoorCore.OnDoorMoveEnd(){}
function DoorCore.OnDoorMove(){} // physics
function DoorCore.OnDoorPreRender( bf ){} // transform

function DoorCore.Init()
{
	this!Trigger.Init();
	
	this.
	{
		openPosition = vec3(0),
		openRotation = quat(),
		closedPosition = vec3(0),
		closedRotation = quat(),
		openingTime = 1,
		initialState = false,
		targetState = false,
		openState = 0.0,
		openTarget = 0.0,
	};
	
	this._pPos = this._cPos = this.GetCurrentPosition();
	this._pRot = this._cRot = this.GetCurrentRotation();
	
	this.OnDoorMove();
	this.OnDoorPreRender( 1.0 );
}

function DoorCore.Open(){ this.targetState = true; }
function DoorCore.Close(){ this.targetState = false; }
function DoorCore.Toggle(){ this.targetState = !this.targetState; }

function DoorCore.GetCurrentPosition()
{
	return lerp( this.closedPosition, this.openPosition, this.openState );
}

function DoorCore.GetCurrentRotation()
{
	return lerp( this.closedRotation, this.openRotation, this.openState );
}

function DoorCore.GetInterpolatedPosition( bf )
{
	return lerp( this._pPos, this._cPos, bf );
}

function DoorCore.GetInterpolatedRotation( bf )
{
	return lerp( this._pRot, this._cRot, bf );
}

function DoorCore.FixedUpdate( dt )
{
	if( this.openState != this.openTarget )
	{
		df = this.openTarget - this.openState;
		df /= this.openingTime;
		df_len = abs( df );
		df_dir = sign( df );
		if( this.openingTime > 0 )
		{
			df_len /= this.openingTime;
			if( df_len > dt )
				df_len = dt;
		}
		else
			df_len = 1;
		this.openState = clamp( this.openState + df_len * df_dir, 0.0, 1.0 );
		
		this.OnDoorMove();
		if( this.openState == this.openTarget )
		{
			this.UpdateState( this.openTarget );
			this.OnDoorMoveEnd();
		}
	}
	else if( this.openTarget != toreal( this.targetState ) )
	{
		this.openTarget = toreal( this.targetState );
		this.OnDoorMoveStart();
	}
	
	this._pPos = this._cPos;
	this._pRot = this._cRot;
	this._cPos = this.GetCurrentPosition();
	this._cRot = this.GetCurrentRotation();
}

function DoorCore.Update( dt, bf )
{
	this.OnDoorPreRender( bf );
}

