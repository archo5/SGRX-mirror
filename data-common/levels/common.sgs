
//
// Editor helper functions
function PropInfo_XForm( eptr )
{
	EE_AddFieldVec3( eptr, "position", "Position", 0, 2 );
	EE_AddFieldVec3( eptr, "rotationXYZ", "Rotation", 0, 2, 0, 360 );
	EE_AddFieldVec3( eptr, "scale", "Scale", 1, 2, 0.01, 100 );
}


//
// Entity extension functions
//
function ENTITY( name, inhname )
{
	data = _G[ name ];
	data.
	{
		__inherit = inhname,
		__getindex = mm_getindex_router,
		__setindex = mm_setindex_router
	};
	sym_register( name, data );
	level.entity_types[ name ] = data;
}

Entity.ED_Icon = "editor/icons/default.png";
function Entity.ED_PropInfo( eptr )
{
	PropInfo_XForm( eptr );
}


//
// Trigger Entity Core
//
global Trigger = {};

function Trigger.Init()
{
	this.
	{
		func = null,
		funcOut = null,
		once = true,
		done = false,
		currState = false,
		lastState = false,
		mask = IEST_Player,
	};
}

function Trigger.Invoke( newstate )
{
	newstate = tobool( newstate );
	curfn = if( newstate, this.func, this.funcOut );
	if( curfn !== null )
	{
		curfn( newstate );
	}
}

function Trigger.UpdateState( newstate )
{
	if( this.currState != newstate && !this.done )
	{
		this.currState = newstate;
		this.Invoke( newstate );
		if( this.once && newstate == this.lastState ) // once on, once off
			this.done = true;
	}
}

function Trigger.SetupTrigger( once, fn, fnout )
{
	this.done = false;
	this.once = tobool( once );
	this.func = fn;
	if( typeof(fnout) == "bool" )
		this.funcOut = if( fnout, fn, null );
	else
		this.funcOut = fnout ?? fn;
}


//
// Trigger Entity - Box
//
global BoxTrigger = clone( Trigger );
ENTITY( "BoxTrigger", "Entity" );

BoxTrigger.ED_Icon = "editor/icons/trigger.png";
function BoxTrigger.ED_PropInfo( eptr )
{
	PropInfo_XForm( eptr );
}

function BoxTrigger.Update( dt )
{
	this.UpdateState( level.QueryOBB( null, this.mask, this.transform ) );
}


//
// Trigger Entity - Sphere
//
global SphereTrigger = clone( Trigger );
ENTITY( "SphereTrigger", "Entity" );

function SphereTrigger.Init()
{
	this!Trigger.Init();
	this.radius = 1;
}

function SphereTrigger.Update( dt )
{
	this.UpdateState( level.QuerySphere( null, this.mask, this.position, this.radius ) );
}


//
// Door Entity Core
//
global DoorCore = clone( Trigger );

// callbacks
function DoorCore.OnDoorMoveStart(){}
function DoorCore.OnDoorMoveEnd(){}
function DoorCore.OnDoorMove(){} // physics
function DoorCore.OnDoorPreRender( bf ){} // transform

function DoorCore.Init()
{
	this!Trigger.Init();
	
	this.
	{
		openPosition = vec3(0),
		openRotation = quat(),
		closedPosition = vec3(0),
		closedRotation = quat(),
		openingTime = 1,
		initialState = false,
		targetState = false,
		openState = 0.0,
		openTarget = 0.0,
	};
	
	this._pPos = this._cPos = this.GetCurrentPosition();
	this._pRot = this._cRot = this.GetCurrentRotation();
	
	this.OnDoorMove();
	this.OnDoorPreRender( 1.0 );
}

function DoorCore.Open(){ this.targetState = true; }
function DoorCore.Close(){ this.targetState = false; }
function DoorCore.Toggle(){ this.targetState = !this.targetState; }

function DoorCore.GetCurrentPosition()
{
	return lerp( this.closedPosition, this.openPosition, this.openState );
}

function DoorCore.GetCurrentRotation()
{
	return lerp( this.closedRotation, this.openRotation, this.openState );
}

function DoorCore.GetInterpolatedPosition( bf )
{
	return lerp( this._pPos, this._cPos, bf );
}

function DoorCore.GetInterpolatedRotation( bf )
{
	return lerp( this._pRot, this._cRot, bf );
}

function DoorCore.FixedUpdate( dt )
{
	if( this.openState != this.openTarget )
	{
		df = this.openTarget - this.openState;
		df /= this.openingTime;
		df_len = abs( df );
		df_dir = sign( df );
		if( this.openingTime > 0 )
		{
			df_len /= this.openingTime;
			if( df_len > dt )
				df_len = dt;
		}
		else
			df_len = 1;
		this.openState = clamp( this.openState + df_len * df_dir, 0.0, 1.0 );
		
		this.OnDoorMove();
		if( this.openState == this.openTarget )
		{
			this.UpdateState( this.openTarget );
			this.OnDoorMoveEnd();
		}
	}
	else if( this.openTarget != toreal( this.targetState ) )
	{
		this.openTarget = toreal( this.targetState );
		this.OnDoorMoveStart();
	}
	
	this._pPos = this._cPos;
	this._pRot = this._cRot;
	this._cPos = this.GetCurrentPosition();
	this._cRot = this.GetCurrentRotation();
}

function DoorCore.Update( dt, bf )
{
	this.OnDoorPreRender( bf );
}

