
function lerp( a, b, s ){ return a * ( 1 - s ) + b * s; }
function sign( x ){ return if( x != 0, if( x > 0, 1, -1 ), 0 ); }

//
// Editor helper functions
_G.
{
	EDPI_Pos_Min = -8192,
	EDPI_Pos_Max = 8192,
};
function PropInfo_XForm( eptr )
{
	EE_AddFieldVec3( eptr, "position", "Position", 0, 2, EDPI_Pos_Min, EDPI_Pos_Max );
	EE_AddFieldVec3( eptr, "rotationXYZ", "Rotation", 0, 1, 0, 360 );
	EE_AddFieldVec3( eptr, "scale", "Scale", 1, 2, 0.01, 100 );
}

global Entity = {};

function Entity.get_transform()
{
	return EE_GenMatrix_SRaP( this.scale, this.rotationXYZ, this.position );
}

global ED_ENTITY_TYPES = {};
function ENTITY( name )
{
	data = _G[ name ];
	class( data, Entity );
	sym_register( name, data );
	ED_ENTITY_TYPES[ name ] = data;
}

function PropInfo_Entity( eptr )
{
	EE_AddFieldString( eptr, "name", "Name", "" );
	EE_AddFieldString( eptr, "id", "Global ID", "" );
	PropInfo_XForm( eptr );
}


//
// System extension functions
//
global ED_SYSTEM_TYPES = {};
function ED_SYSTEM_TYPES.AIDBSystem( ui )
{
	@(this.defaultRestrictions ??= 0x1);
	@(this.defaultSuspicionFactor ??= 1000);
	
	ui.EditFlag( "Restricted - player", this, "defaultRestrictions", 0x01 );
	ui.EditFloat( "Default suspicion factor", this, "defaultSuspicionFactor", 0, 100000 );
}


//
// Game object extension functions
//
function BEHAVIOR( name, inhname )
{
	data = _G[ name ];
	data.
	{
		__inherit = inhname,
		__getindex = mm_getindex_router,
		__setindex = mm_setindex_router
	};
	sym_register( name, data );
	level.behavior_types[ name ] = data;
}


//
// Resource Editor Extensions
//

function GOResource.EditorGUI( ui )
{
	ui.EditXFMat4( "Matrix", this, "localMatrix" );
	ui.ComboNT( "Matrix mode", this, "matrixMode", "Relative\0Absolute\0" );
}

MeshResource.ED_Icon = "editor/icons/mesh.png";
function MeshResource.EditorGUI( ui )
{
	ui.PickMesh( "Mesh", this, "mesh", "Select mesh" );
	this!GOResource.EditorGUI( ui );
	ui.ComboNT( "Lighting mode", this, "lightingMode", "Unlit\0Static\0Dynamic\0Decal\0" );
	ui.EditBool( "Is visible?", this, "visible" );
	ui.EditBool( "Is static?", this, "isStatic" );
	if( this.isStatic )
	{
		ui.EditFloat( "Lightmap quality", this, "lmQuality", 0.01, 100 );
		ui.EditBool( "Casts lightmap shadows?", this, "castLMS" );
	}
}

LightResource.ED_Icon = "editor/icons/light.png";
function LightResource.EditorGUI( ui )
{
	ui.ComboNT( "Type", this, "type", "Point light\0Spotlight\0", 1 );
	ui.EditBool( "Enabled", this, "enabled" );
	ui.EditBool( "Has shadows?", this, "hasShadows" );
	ui.EditColorRGBLDR( "Color", this, "color" );
	ui.EditFloat( "Intensity", this, "intensity", -1000, 1000 );
	ui.EditFloat( "Range", this, "range", 0, 10000 );
	ui.EditFloat( "Power", this, "power", 0.01, 100 );
	if( this.type == LIGHT_SPOT )
	{
		ui.EditFloat( "Angle (outer)", this, "angle", 0, 180 );
		ui.EditFloat( "Aspect", this, "aspect", 1/4096, 4096 );
	}
	this!GOResource.EditorGUI( ui );
	ui.PickTexture( "Cookie texture", this, "cookieTexture", "Select cookie texture" );
	ui.EditBool( "Is static?", this, "isStatic" );
	if( this.isStatic )
	{
		ui.EditFloat( "Angle (inner)", this, "innerAngle", 0, 180 );
		ui.EditFloat( "Spotlight curve", this, "spotCurve", 0.01, 100 );
		ui.EditFloat( "Light radius", this, "lightRadius", 0, 1000 );
	}
}
function LightResource.EditorDrawWorld()
{
	p = this.GetWorldMatrix().transform_pos( vec3(0) );
	r1 = this.range;
	r2 = pow( 0.5, this.power ) * this.range;
	BR_Reset();
	if( this.type == LIGHT_SPOT )
	{
		d = this.GetWorldMatrix().transform_normal( vec3(0,0,-1) ).normalized;
		u = this.GetWorldMatrix().transform_normal( vec3(0,-1,0) ).normalized;
		BR_Col( 0.9, 0.8, 0.1, 0.5 );
		BR_ConeOutline( p, d, u, r1, this.angle, 32 );
		BR_Col( 0.9, 0.5, 0.1, 0.5 );
		BR_ConeOutline( p, d, u, r2, this.angle, 32 );
	}
	else
	{
		BR_Col( 0.9, 0.8, 0.1, 0.5 );
		BR_SphereOutline( p, r1, 64 );
		BR_Col( 0.9, 0.5, 0.1, 0.5 );
		BR_SphereOutline( p, r2, 32 );
	}
}

ParticleSystemResource.ED_Icon = "editor/icons/particles.png";
function ParticleSystemResource.EditorGUI( ui )
{
	ui.EditBool( "Enabled", this, "enabled" );
	ui.PickPartSys( "Particle system", this, "particleSystemPath", "Select particle system" );
	ui.PickSound( "Sound event", this, "soundEvent", "Select sound event" );
	this!GOResource.EditorGUI( ui );
}

SoundSourceResource.ED_Icon = "editor/icons/sound.png";
function SoundSourceResource.EditorGUI( ui )
{
	ui.EditBool( "Enabled", this, "enabled" );
	ui.PickSound( "Sound event", this, "soundEvent", "Select sound event" );
	this!GOResource.EditorGUI( ui );
}

RigidBodyResource.ED_Icon = "editor/icons/rigid_body.png";
function RigidBodyResource.EditorGUI( ui )
{
	ui.EditFloat( "Friction", this, "friction", 0, 1 );
	ui.EditFloat( "Restitution", this, "restitution", 0, 1 );
	ui.EditFloat( "Mass", this, "mass", 0, 10000 );
	ui.EditFloat( "Linear damping", this, "linearDamping", 0, 1 );
	ui.EditFloat( "Angular damping", this, "angularDamping", 0, 1 );
	ui.EditBool( "Is kinematic?", this, "kinematic" );
	ui.EditBool( "Can sleep?", this, "canSleep" );
	ui.EditBool( "Is enabled?", this, "enabled" );
	ui.EditMask( "Group", this, "group", 16 );
	ui.EditMask( "Mask", this, "mask", 16 );
	ui.ComboNT( "Shape type", this, "shapeType", "AABB\0Box\0Sphere\0Cylinder\0Capsule\0Mesh\0" );
	ui.EditFloat( "Radius [sph/cap]", this, "shapeRadius", 0.01, 1000 );
	ui.EditFloat( "Height [cap]", this, "shapeHeight", 0.01, 1000 );
	ui.EditVec3( "Extents [cyl/box/aabb]", this, "shapeExtents", -1000, 1000 );
	ui.EditVec3( "Min. extents [aabb]", this, "shapeMinExtents", -1000, 1000 );
	ui.PickMesh( "Mesh", this, "shapeMesh", "Select shape mesh" );
	this!GOResource.EditorGUI( ui );
	ui.EditVec3( "Linear velocity", this, "linearVelocity", -10000, 10000 );
	ui.EditVec3( "Angular velocity", this, "angularVelocity", -10000, 10000 );
}
function RigidBodyResource.EditorDrawWorld()
{
	BR_Reset();
	BR_Col( 0.1, 0.2, 0.8, 1 );
	BR_AABB( this.shapeMinExtents, this.shapeExtents, this.GetWorldMatrix() );
}

function ReflectionPlaneResource.EditorGUI( ui )
{
	this!GOResource.EditorGUI( ui );
}
function ReflectionPlaneResource.EditorDrawWorld()
{
	mtx = this.GetWorldMatrix();
	BR_Reset();
	BR_Col( 0.2, 0.8, 0.1, 0.05 );
	BR_SetPrimitiveType( PT_Lines );
	BR_Pos( mtx.transform_pos( vec3(0) ) );
	BR_Pos( mtx.transform_pos( vec3(0,0,1) ) );
}

CameraResource.ED_Icon = "editor/icons/camera.png";
function CameraResource.EditorGUI( ui )
{
	ui.EditBool( "Is enabled?", this, "enabled" );
	ui.EditFloat( "Field of view", this, "fieldOfView", 0, 180 );
	ui.EditFloat( "Aspect H/V mix", this, "aspectMix", 0, 1 );
	ui.EditFloat( "Near plane", this, "nearPlane", 0, 1000000 );
	ui.EditFloat( "Far plane", this, "nearPlane", 0, 1000000 );
	this!GOResource.EditorGUI( ui );
}


//
// Basic behaviors
//

// === CONTROLLERS === //
function BhControllerBase.EditorGUI( ui )
{
	ui.EditBool( "Enabled", this, "enabled" );
}

// === RESOURCE - MOVE OBJECT === //
BEHAVIOR( "BhResourceMoveObject", "GOBehavior" );
function BhResourceMoveObject.EditorGUI( ui )
{
	ui.PickLocalRsrc( "Resource", this, "resource", this.object );
	ui.EditFlag( "Transfer position", this, "mask", 0x01 );
	ui.EditFlag( "Transfer rotation", this, "mask", 0x02 );
	ui.EditFlag( "Transfer scale", this, "mask", 0x04 );
}
// === RESOURCE - MOVE RESOURCE === //
BEHAVIOR( "BhResourceMoveResource", "GOBehavior" );
function BhResourceMoveResource.EditorGUI( ui )
{
	ui.PickLocalRsrc( "Resource", this, "resource", this.object );
	ui.PickLocalRsrc( "Follow", this, "follow", this.object );
	ui.EditFlag( "Transfer position", this, "mask", 0x01 );
	ui.EditFlag( "Transfer rotation", this, "mask", 0x02 );
	ui.EditFlag( "Transfer scale", this, "mask", 0x04 );
}

// === OBJECT ROTATOR === //
global BhObjectRotate = {};
BEHAVIOR( "BhObjectRotate", "GOBehavior" );
function BhObjectRotate.Init()
{
	this.speed = vec3(0,0,180);
}
function BhObjectRotate.Update()
{
//	this.object.rotationXYZ += this.speed * level.deltaTime;
}
function BhObjectRotate.EditorGUI( ui )
{
	ui.EditVec3( "Speed", this, "speed", -100000, 100000 );
}

// === OBJECT SINE MOVER === //
class BhObjectMoveSine : GOBehavior
{
	function Init()
	{
		this.speed = 1;
		this.axis = vec3(0,0,1);
		this.pos = this.object.position;
	}
	function Update()
	{
		this.object.position = this.pos + this.axis * sin( this.speed * ( level.GetPhyTime() / 1000 ) * 2 * M_PI );
	}
	function EditorGUI( ui )
	{
		ui.EditFloat( "Speed", this, "speed", -100000, 100000 );
		ui.EditVec3( "Axis", this, "axis", -100000, 100000 );
	}
	function EditorDrawWorld()
	{
		BR_Reset();
		BR_SetPrimitiveType( PT_Lines );
		BR_Col( 0.1, 0.9, 0.1, 0.8 );
		BR_Pos( this.object.position );
		BR_Pos( this.object.position + this.axis );
		BR_Col( 0.9, 0.1, 0.1, 0.8 );
		BR_Pos( this.object.position );
		BR_Pos( this.object.position - this.axis );
	}
}
BEHAVIOR( "BhObjectMoveSine", "GOBehavior" );

// === OBJECT DOOR MOVER === //
class BhObjectMoveDoorSlide : GOBehavior
{
	function Init()
	{
		this.speed = 1;
		this.offset = vec3(0,0,2);
		this.pos = this.object.position;
		this.factor = 0;
		this.openTarget = false;
	}
	function OnTriggerChange( newState )
	{
		this.openTarget = newState;
	}
	function Update()
	{
		target = if( this.openTarget, 1, 0 );
		diff = ( target - this.factor );
		this.factor = clamp( this.factor + min( abs( diff ), this.speed * level.deltaTime ) * sign( diff ), 0, 1 );
		this.object.position = this.pos + this.object.LocalToWorldDir( this.offset ) * this.factor;
	}
	function EditorGUI( ui )
	{
		ui.EditFloat( "Speed", this, "speed", -100000, 100000 );
		ui.EditVec3( "Offset", this, "offset", -100000, 100000 );
	}
	function EditorDrawWorld()
	{
		BR_Reset();
		BR_SetPrimitiveType( PT_Lines );
		BR_Col( 0.1, 0.5, 0.9, 0.8 );
		BR_Pos( this.object.position );
		BR_Pos( this.object.position + this.object.LocalToWorldDir( this.offset ) );
	}
}
BEHAVIOR( "BhObjectMoveDoorSlide", "GOBehavior" );

// === BOX TRIGGER === //
class BhBoxTrigger : GOBehavior
{
	function Init()
	{
		this.extents = vec3(1,1,1);
		this.offset = vec3(0,0,0);
		this.prevState = false;
	}
	function Update()
	{
		found = level.QueryOBB( null, IEST_Target, this._GetTransform() );
		newState = found;
		
		this.OnTriggerPollFunc( newState );
		if( newState )
			this.OnTriggerInsideFunc();
		if( newState != this.prevState )
		{
			this.prevState = newState;
			this.OnTriggerChangeFunc( newState );
		}
	}
	function _GetTransform()
	{
		return mat4()
			.scale_v3( this.extents )
			.translate_v3( this.offset )
			.multiply( this.object.transform );
	}
	
	// override for custom behavior:
	function OnTriggerInsideFunc(){}
	function OnTriggerPollFunc( newState ){}
	function OnTriggerChangeFunc( newState )
	{
		this.object.SendMessage( "OnTriggerChange", newState );
	}
	
	function EditorGUI( ui )
	{
		ui.EditVec3( "Extents", this, "extents", -100000, 100000 );
		ui.EditVec3( "Offset", this, "offset", -100000, 100000 );
	}
	function EditorDrawWorld()
	{
		BR_Reset();
		BR_Col( 0.1, 0.8, 0.9, 0.8 );
		BR_AABB( -1, 1, this._GetTransform() );
	}
}
BEHAVIOR( "BhBoxTrigger", "GOBehavior" );

// === SPHERE TRIGGER === //
class BhSphereTrigger : GOBehavior
{
	function Init()
	{
		this.radius = 1;
		this.sticky = false;
		this.offset = vec3(0,0,0);
		this.prevState = false;
		this.savedPosition = null;
	}
	function _getPos()
	{
		return if( this.sticky, this.savedPosition,
			this.object.LocalToWorld( this.offset ) );
	}
	function Update()
	{
		if( this.sticky && this.savedPosition === null )
			this.savedPosition = this.object.LocalToWorld( this.offset );
		
		newState = this.DoQuery();
		if( newState != this.prevState )
		{
			this.prevState = newState;
			this.OnTriggerChangeFunc( newState );
		}
	}
	function DoQuery()
	{
		found = false;
		self = this;
		function fn( obj ) use( found, self )
		{
			found = self.CheckObject( obj );
			return found;
		}
		procany = level.QuerySphere( fn, IEST_Target, this._getPos(), this.radius );
		return found, procany;
	}
	function CheckObject( obj ){ return true; }
	function OnTriggerChangeFunc( newState )
	{
		this.object.SendMessage( "OnTriggerChange", newState );
	}
	function EditorGUI( ui )
	{
		ui.EditFloat( "Radius", this, "radius", -100000, 100000 );
		ui.EditVec3( "Offset", this, "offset", -100000, 100000 );
		ui.EditBool( "Sticky", this, "sticky" );
	}
	function EditorDrawWorld()
	{
		BR_Reset();
		BR_Col( 0.1, 0.8, 0.9, 0.8 );
		BR_SphereOutline( this.object.LocalToWorld( this.offset ), this.radius, 32 );
	}
}
BEHAVIOR( "BhSphereTrigger", "GOBehavior" );

// === MESH ARRAY === //
global BhMeshArray = {};
BEHAVIOR( "BhMeshArray", "GOBehavior" );
BhMeshArray._props = [
	"isStatic", "visible", "mesh", "localMatrix",
	"matrixMode", "lightingMode", "lmQuality", "castLMS"
];
function BhMeshArray.Init()
{
	this.object.RequireResource( "ma_0", GO_RSRC_MESH );
	this.offset = mat4().translate( 0, 0, 1 );
	this.count = 1;
}
function BhMeshArray.Rebuild()
{
	this.object.RequireResource( "ma_0", GO_RSRC_MESH );
	r0 = this.resources[ "ma_0" ];
	
	// remove the too many meshes
	names = this.resources.GetNames();
	foreach( name : names )
	{
		if( string_part( name, 0, 3 ) == "ma_" )
		{
			which = toint( string_part( name, 3 ) );
			if( which >= this.count )
			{
				this.object.RemoveResource( name );
			}
		}
	}
	
	_props = this._props;
	xfadd = mat4(this.offset);
	for( i = 1; i < this.count; ++i )
	{
		name = "ma_" $ i;
		this.object.RequireResource( name, GO_RSRC_MESH );
		r = this.resources[ name ];
		for( j = 0; j < _props.size; ++j )
		{
			prop = _props[ j ];
			r.(prop) = r0.(prop);
		}
		r.localMatrix = r.localMatrix.multiply( xfadd );
		xfadd.multiply( this.offset );
	}
}
function BhMeshArray.EditorGUI( ui )
{
	ui.EditXFMat4( "Offset", this, "offset" );
	ui.EditInt( "Count", this, "count", 1, 1000 );
	if( ui.Button( "Regenerate" ) )
		this.Rebuild();
}


//
// Entity Editor Extensions
//

global Marker = {};
ENTITY( "Marker" );

Marker.ED_Icon = "editor/icons/marker.png";
function Marker.ED_PropInfo( eptr )
{
	EE_AddFieldString( eptr, "name", "Name", "" );
	EE_AddFieldVec3( eptr, "position", "Position", 0, 2, EDPI_Pos_Min, EDPI_Pos_Max );
}
function Marker.EditorDrawWorld()
{
	BR_Reset();
	BR_Col( 0.9, 0.2, 0.1, 0.8 );
	BR_Tick( this.position, 0.1 );
}


global LightSample = {};
ENTITY( "LightSample" );

LightSample.ED_Icon = "editor/icons/ltsample.png";
function LightSample.ED_PropInfo( eptr )
{
	EE_AddFieldVec3( eptr, "position", "Position", 0, 2, EDPI_Pos_Min, EDPI_Pos_Max );
}
function LightSample.EditorDrawWorld()
{
}


global MapLayer = {};
ENTITY( "MapLayer" );

MapLayer.ED_Icon = "editor/icons/marker.png";
function MapLayer.ED_PropInfo( eptr )
{
	EE_AddFieldVec3( eptr, "position", "Position", 0, 2, EDPI_Pos_Min, EDPI_Pos_Max );
}
function MapLayer.EditorDrawWorld()
{
}


global SolidBox = {};
ENTITY( "SolidBox" );

SolidBox.ED_Icon = "editor/icons/trigger.png";
function SolidBox.ED_PropInfo( eptr )
{
	PropInfo_XForm( eptr );
}
function SolidBox.EditorDrawWorld()
{
	BR_Reset();
	BR_Col( 0.2, 0.3, 0.8, 0.8 );
	BR_AABB( -1, 1, this.get_transform() );
}


global AICover = {};
ENTITY( "AICover" );

AICover.ED_Icon = "editor/icons/trigger.png";
function AICover.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
	EE_AddFieldBool( eptr, "negative", "Is negative (excluding)?", false );
}
function AICover.EditorDrawWorld()
{
	BR_Reset();
	BR_Col( 0.2, 0.3, 0.8, 0.8 );
	BR_AABB( -1, 1, this.get_transform() );
}


global AIPathArea = {};
ENTITY( "AIPathArea" );

AIPathArea.ED_Icon = "editor/icons/trigger.png";
function AIPathArea.ED_PropInfo( eptr )
{
	PropInfo_XForm( eptr );
}
function AIPathArea.EditorDrawWorld()
{
	BR_Reset();
	BR_Col( 0.2, 0.6, 0.8, 0.8 );
	BR_AABB( -1, 1, this.get_transform() );
}


global AIRoom = {};
ENTITY( "AIRoom" );
function AIRoom.Init()
{
	this.negative = false;
	this.cellSize = 1.0;
}

AIRoom.ED_Icon = "editor/icons/trigger.png";
function AIRoom.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
	EE_AddFieldBool( eptr, "negative", "Is negative (excluding)?", false );
	EE_AddFieldFloat( eptr, "cellSize", "Cell size", 0.5, 2, 0.01, 100 );
}
function AIRoom.EditorDrawWorld()
{
	scale = this.scale;
	mtx = this.get_transform();
	BR_Reset();
	BR_Col( 0.2, 0.9, 0.8, 0.8 );
	BR_AABB( -1, 1, mtx );
	if( this.negative == false && this.cellSize > 0.01 )
	{
		xcount = floor( scale.x / this.cellSize );
		ycount = floor( scale.y / this.cellSize );
		xncs = this.cellSize / scale.x;
		yncs = this.cellSize / scale.y;
		for( y = 0; y < ycount; ++y )
		{
			for( x = 0; x < xcount; ++x )
			{
				pos = vec3( ( x * 2 - (xcount-1) ) * xncs, ( y * 2 - (ycount-1) ) * yncs, 0 );
				BR_Tick( mtx.transform_pos( pos ), this.cellSize * 0.9 );
			}
		}
	}
}


global AIZone = {};
ENTITY( "AIZone" );
function AIZone.Init()
{
	this.restrictedGroups = 1;
	this.suspicionFactor = 1;
	this.priority = 0;
}

AIZone.ED_Icon = "editor/icons/trigger.png";
function AIZone.ED_PropInfo( eptr )
{
	PropInfo_XForm( eptr );
	EE_AddFieldInt( eptr, "restrictedGroups", "Restricted groups", 1 );
	EE_AddFieldFloat( eptr, "suspicionFactor", "Suspicion factor", 1, 2, 0, 100000 );
	EE_AddFieldInt( eptr, "priority", "Priority", 0 );
}
function AIZone.EditorDrawWorld()
{
	BR_Reset();
	BR_Col( 0.9, 0.9, 0.7, 0.8 );
	BR_AABB( -1, 1, this.get_transform() );
}


//
// Trigger Entity Core
//
global Trigger = {};

function Trigger.Init()
{
	this.
	{
		func = null,
		funcOut = null,
		once = true,
		done = false,
		currState = false,
		lastState = false,
		mask = IEST_Player,
	};
}

function Trigger.Invoke( newstate )
{
	newstate = tobool( newstate );
	curfn = if( newstate, this.func, this.funcOut );
	if( curfn !== null )
	{
		curfn( newstate );
	}
}

function Trigger.UpdateState( newstate )
{
	if( this.once < 0 || ( this.currState != newstate && !this.done ) )
	{
		this.currState = newstate;
		this.Invoke( newstate );
		if( this.once > 0 && newstate == this.lastState ) // once on, once off
			this.done = true;
	}
}

function Trigger.SetupTrigger( once, fn, fnout )
{
	this.done = false;
	this.once = toint( once );
	this.func = fn;
	if( typeof(fnout) == "bool" )
		this.funcOut = if( fnout, fn, null );
	else
		this.funcOut = fnout;
}


//
// Trigger Entity - Box
//
global BoxTrigger = clone( Trigger );
ENTITY( "BoxTrigger" );

BoxTrigger.ED_Icon = "editor/icons/trigger.png";
function BoxTrigger.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
}
function BoxTrigger.EditorDrawWorld()
{
	BR_Reset();
	BR_Col( 0.1, 0.4, 0.9 );
	BR_AABB( -1, 1, this.get_transform() );
}

function BoxTrigger.Update( dt )
{
	this.UpdateState( level.QueryOBB( null, this.mask, this.get_transform() ) );
}


//
// Trigger Entity - Sphere
//
global SphereTrigger = clone( Trigger );
ENTITY( "SphereTrigger" );

function SphereTrigger.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
	EE_AddFieldFloat( eptr, "radius", "Radius", 1, 2, 0.01, 1000 );
}

function SphereTrigger.Init()
{
	this!Trigger.Init();
	this.radius = 1;
}

function SphereTrigger.Update( dt )
{
	this.UpdateState( level.QuerySphere( null, this.mask, this.position, this.radius ) );
}


//
// Door Entity Core
//
global DoorCore = clone( Trigger );

// callbacks
function DoorCore.OnDoorMoveStart(){}
function DoorCore.OnDoorMoveEnd(){}
function DoorCore.OnDoorMove(){} // physics
function DoorCore.OnDoorPreRender( bf ){} // transform

function DoorCore.Init()
{
	this!Trigger.Init();
	
	this._data.
	{
		openPosition = vec3(0),
		openRotation = quat(),
		closedPosition = vec3(0),
		closedRotation = quat(),
		openingTime = 1,
		targetState = false,
		openState = 0.0,
		openTarget = 0.0,
		ev_finished = event(true),
	};
	
	this._OnReposition();
}

function DoorCore._OnReposition()
{
	this._pPos = this._cPos = this.GetCurrentPosition();
	this._pRot = this._cRot = this.GetCurrentRotation();
	this.OnDoorMove();
	this.OnDoorPreRender( 1.0 );
}

function DoorCore.__get_initialState(){ return this.openState; }
function DoorCore.__set_initialState( v )
{
	v = toreal( v );
	this.targetState = v > 0.5;
	this.openState = v;
	this.openTarget = v;
	this._OnReposition();
}

function DoorCore.Open()
{
	this.targetState = true;
	this.ev_finished.signaled = false;
}
function DoorCore.Close()
{
	this.targetState = false;
	this.ev_finished.signaled = false;
}
function DoorCore.Toggle()
{
	this.targetState = !this.targetState;
	this.ev_finished.signaled = false;
}

function DoorCore.GetCurrentPosition()
{
	return lerp( this.closedPosition, this.openPosition, this.openState );
}

function DoorCore.GetCurrentRotation()
{
	return quat_slerp( this.closedRotation, this.openRotation, this.openState );
}

function DoorCore.GetInterpolatedPosition( bf )
{
	return lerp( this._pPos, this._cPos, bf );
}

function DoorCore.GetInterpolatedRotation( bf )
{
	return quat_slerp( this._pRot, this._cRot, bf );
}

function DoorCore.PrePhysicsFixedUpdate( dt )
{
	if( this.openState != this.openTarget )
	{
		df = this.openTarget - this.openState;
		df_len = abs( df );
		df_dir = sign( df );
		if( this.openingTime > 0 )
		{
			dtot = dt / this.openingTime;
			if( df_len > dtot )
				df_len = dtot;
		}
		else
			df_len = 1;
		df_len += 0.001;
		this.openState = clamp( this.openState + df_len * df_dir, 0.0, 1.0 );
		
		this.OnDoorMove();
		if( this.openState == this.openTarget )
		{
			this.UpdateState( this.openTarget );
			this.OnDoorMoveEnd();
		}
	}
	else if( this.openTarget != toreal( this.targetState ) )
	{
		this.openTarget = toreal( this.targetState );
		this.OnDoorMoveStart();
	}
	this.ev_finished.signaled = this.openState == this.openTarget;
	
	this._pPos = this._cPos;
	this._pRot = this._cRot;
	this._cPos = this.GetCurrentPosition();
	this._cRot = this.GetCurrentRotation();
}

function DoorCore.Update( dt, bf )
{
	this.OnDoorPreRender( bf );
}


global BasicDoor = clone( DoorCore );
ENTITY( "BasicDoor" );

function BasicDoor.Init()
{
	this!DoorCore.Init();
	
	this.
	{
		meshEnt = level.CreateEntity( "Mesh" ).
		{
			name = "door",
			parent = this,
			isStatic = false,
			lightingMode = LM_Dynamic,
			solid = false,
		},
		bodyEnt = level.CreateEntity( "RigidBody" ).
		{
			name = "door",
			parent = this,
			shapeType = ShapeType_AABB,
		//	kinematic = true,
		},
	};
}

function BasicDoor.OnDestroy()
{
	level.DestroyEntity( this.meshEnt );
	level.DestroyEntity( this.bodyEnt );
}

function BasicDoor.__get_mesh(){ return this.meshEnt.mesh; }
function BasicDoor.__set_mesh( v )
{
	this.meshEnt.mesh = v;
	md = this.meshEnt.meshData;
	if( md !== null )
	{
		this.bodyEnt.shapeExtents = md.boundsMax;
		this.bodyEnt.shapeMinExtents = md.boundsMin;
		this.bodyEnt.shapeMesh = md;
	}
}
function BasicDoor.__get_castLMS(){ return this.meshEnt.castLMS; }
function BasicDoor.__set_castLMS( v ){ this.meshEnt.castLMS = v; }
function BasicDoor.__get_meshCollisions(){ return this.bodyEnt.shapeType == ShapeType_Mesh; }
function BasicDoor.__set_meshCollisions( v ){ this.bodyEnt.shapeType = if( v, ShapeType_Mesh, ShapeType_AABB ); }
function BasicDoor.__set_closedPosition( v ){ this._data.closedPosition = v; this._OnReposition(); }
function BasicDoor.__set_openPosition( v ){ this._data.openPosition = v; this._OnReposition(); }
function BasicDoor.__get_closedRotationXYZ(){ return quat2euler( this.closedRotation ); }
function BasicDoor.__set_closedRotationXYZ( v ){ this.closedRotation = euler2quat( v ); this._OnReposition(); }
function BasicDoor.__get_openRotationXYZ(){ return quat2euler( this.openRotation ); }
function BasicDoor.__set_openRotationXYZ( v ){ this.openRotation = euler2quat( v ); this._OnReposition(); }

function BasicDoor._MoveDoor( p, r )
{
	for( i = 0, cc = this.childCount; i < cc; ++i )
	{
		ch = this.GetChild( i );
		if( ch.name != "door" )
			continue;
		ch.localPosition = p;
		ch.localRotation = r;
	}
}

function BasicDoor.OnDoorMove()
{
	this._MoveDoor(
		this.GetCurrentPosition(),
		this.GetCurrentRotation()
	);
}

function BasicDoor.OnDoorPreRender( bf )
{
	this._MoveDoor(
		this.GetInterpolatedPosition( bf ),
		this.GetInterpolatedRotation( bf )
	);
}

function BasicDoor.ED_PropInfo( eptr )
{
	PropInfo_Entity( eptr );
	EE_AddFieldMesh( eptr, "mesh", "Mesh" );
	EE_AddFieldVec3( eptr, "closedPosition", "Closed position", vec3(0,0,0), 2, -100, 100 );
	EE_AddFieldVec3( eptr, "closedRotationXYZ", "Closed rotation", vec3(0,0,0), 2, 0, 360 );
	EE_AddFieldVec3( eptr, "openPosition", "Open position", vec3(0,0,1), 2, -100, 100 );
	EE_AddFieldVec3( eptr, "openRotationXYZ", "Open rotation", vec3(0,0,0), 2, 0, 360 );
	EE_AddFieldFloat( eptr, "openingTime", "Opening time", 1, 2, 0.01, 100 );
	EE_AddFieldFloat( eptr, "initialState", "Initial openness", 0, 2, 0, 1 );
	EE_AddFieldBool( eptr, "castLMS", "[dyn] Cast lightmap shadow", true );
	EE_AddFieldBool( eptr, "meshCollisions", "Mesh collisions", false );
}

function BasicDoor.EditorDrawWorld()
{
	BR_Reset();
	BR_Col( 0.6, 0.6, 0.1, 1 );
	BR_AABB( this.bodyEnt.shapeMinExtents,
		this.bodyEnt.shapeExtents,
		this.bodyEnt.transform );
	BR_Col( 0.8, 0.3, 0.1, 1 );
	BR_Tick( this.LocalToWorld( this.closedPosition ), 0.1 );
	BR_Col( 0.3, 0.8, 0.1, 1 );
	BR_Tick( this.LocalToWorld( this.openPosition ), 0.1 );
}

