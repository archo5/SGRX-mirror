#include "__eq"


struct PointLight /* size: 2c */
{
	float4 vposrad;
	float4 colpow;
};
struct SpotLight /* size: 4c */
{
	PointLight PL;
	float4 vdirang;
	float4 shminfo;
};


UNIFORM_BUFFER( core_data, 0 )
	UNIFORM_VAR( float4x4 mView, 0 );
	UNIFORM_VAR( float4x4 mProj, 4 );
	UNIFORM_VAR( float4x4 mInvView, 8 );
	UNIFORM_VAR( float3 cameraPos, 12 );
	UNIFORM_VAR( float4 timeVals, 13 );
	UNIFORM_VAR( float4 viewportSizeInv, 14 );
	UNIFORM_VAR( float3 gAmbLightColor, 15 );
	UNIFORM_VAR( float3 gDirLightDir, 16 );
	UNIFORM_VAR( float3 gDirLightColor, 17 );
UNIFORM_BUFFER_END;

UNIFORM_BUFFER( instance_data, 1 )
	UNIFORM_VAR( float4x4 mWorld, 17 );
	UNIFORM_VAR( float4x4 mWorldView, 21 );
	UNIFORM_VAR( float4 gInstanceData[16], 25 );
UNIFORM_BUFFER_END;

UNIFORM_BUFFER( instance_light_count, 2 )
	UNIFORM_VAR( float2 gLightCounts, 41 );
UNIFORM_BUFFER_END;

#ifdef SKIN
UNIFORM_BUFFER( skin_matrices, 3 )
	UNIFORM_VAR( float4x4 mSkin[32], 42 );
UNIFORM_BUFFER_END;
#endif // SKIN

#if NUM_POINTLIGHTS > 0
UNIFORM_BUFFER( point_light_data, 4 )
	UNIFORM_VAR( PointLight gPLights[16], 170 );
UNIFORM_BUFFER_END;
#endif // NUM_POINTLIGHTS > 0

#if NUM_SPOTLIGHTS > 0
UNIFORM_BUFFER( spot_light_data_vs, 5 )
	UNIFORM_VAR( float4x4 mSpotLight[ NUM_SPOTLIGHTS ], 202 );
UNIFORM_BUFFER_END;

UNIFORM_BUFFER( spot_light_data_ps, 6 )
	UNIFORM_VAR( SpotLight gSLights[ NUM_SPOTLIGHTS ], 210 );
UNIFORM_BUFFER_END;
#endif // NUM_SPOTLIGHTS > 0


#if NUM_SPOTLIGHTS > 1
#  define SGRX_SPOTLIGHT_DATA( id0, id1 ) \
	float4 SLPPos0 : TEXCOORD##id0; \
	float4 SLPPos1 : TEXCOORD##id1;
#  define SGRX_SPOTLIGHT_VS_TRANSFER( o, worldPos ) \
	o.SLPPos0 = mul( mSpotLight[0], worldPos ); \
	o.SLPPos1 = mul( mSpotLight[1], worldPos );
#elif NUM_SPOTLIGHTS > 0
#  define SGRX_SPOTLIGHT_DATA( id0, id1 ) \
	float4 SLPPos0 : TEXCOORD##id0;
#  define SGRX_SPOTLIGHT_VS_TRANSFER( o, worldPos ) \
	o.SLPPos0 = mul( mSpotLight[0], worldPos );
#else
#  define SGRX_SPOTLIGHT_DATA( id0, id1 )
#  define SGRX_SPOTLIGHT_VS_TRANSFER( o, worldPos )
#endif


#ifdef SKIN
#  define SGRX_SKIN_MESH( i ) i.pos = \
		mul( mSkin[ i.idcs[0] ], float4( i.pos, 1 ) ).xyz * i.wts[0] + \
		mul( mSkin[ i.idcs[1] ], float4( i.pos, 1 ) ).xyz * i.wts[1] + \
		mul( mSkin[ i.idcs[2] ], float4( i.pos, 1 ) ).xyz * i.wts[2] + \
		mul( mSkin[ i.idcs[3] ], float4( i.pos, 1 ) ).xyz * i.wts[3]; \
	i.tan.xyz = \
		mul( mSkin[ i.idcs[0] ], i.tan.xyz ) * i.wts[0] + \
		mul( mSkin[ i.idcs[1] ], i.tan.xyz ) * i.wts[1] + \
		mul( mSkin[ i.idcs[2] ], i.tan.xyz ) * i.wts[2] + \
		mul( mSkin[ i.idcs[3] ], i.tan.xyz ) * i.wts[3]; \
	i.nrm = \
		mul( mSkin[ i.idcs[0] ], i.nrm ) * i.wts[0] + \
		mul( mSkin[ i.idcs[1] ], i.nrm ) * i.wts[1] + \
		mul( mSkin[ i.idcs[2] ], i.nrm ) * i.wts[2] + \
		mul( mSkin[ i.idcs[3] ], i.nrm ) * i.wts[3];
#else
#  define SGRX_SKIN_MESH( i )
#endif


NEEDS_TEXTURE_2D(0);
NEEDS_TEXTURE_2D(1);
NEEDS_TEXTURE_2D(2);
NEEDS_TEXTURE_2D(3);
NEEDS_TEXTURE_2D(4);
NEEDS_TEXTURE_2D(5);
NEEDS_TEXTURE_2D(6);
NEEDS_TEXTURE_2D(7);
NEEDS_TEXTURE_2D(8);
NEEDS_TEXTURE_2D(9);
NEEDS_TEXTURE_CUBE(10);
NEEDS_TEXTURE_2D(11);
#define InstTex0 Tex8
#define InstTex1 Tex9
#define InstTex2 Tex10
#define InstTex3 Tex11

#ifdef NUM_SPOTLIGHTS
NEEDS_TEXTURE_2D(12);
NEEDS_TEXTURE_SM(13);
NEEDS_TEXTURE_2D(14);
NEEDS_TEXTURE_SM(15);
#endif


float3 ModelToWorldPos( float3 p ){ return mul( mWorld, float4( p, 1 ) ).xyz; }
float3 ModelToWorldDir( float3 d ){ return mul( mWorld, float4( d, 0 ) ).xyz; }
float3 WorldToViewPos( float3 p ){ return mul( mView, float4( p, 1 ) ).xyz; }
float3 WorldToViewDir( float3 d ){ return mul( mView, float4( d, 0 ) ).xyz; }
float3 ModelToViewPos( float3 p ){ return mul( mWorldView, float4( p, 1 ) ).xyz; }
float3 ViewToWorldDir( float3 d ){ return mul( mInvView, float4( d, 0 ) ).xyz; }
float4 ViewToProjPos( float3 p ){ return mul( mProj, float4( p, 1 ) ); }

float3x3 CreateTBNMatrix( float3 normal, float4 tangent )
{
	tangent.xyz = normalize( tangent.xyz );
	normal = normalize( normal );
	float3 bitangent = normalize( cross( normal, tangent.xyz ) * tangent.w );
	return float3x3( tangent.xyz, bitangent, normal );
}

float4 DiffuseTexGamma( float4 col )
{
	col.rgb *= col.rgb;
	return col;
}


struct vsinput_particle
{
	float4 pos : POSITION0;
	float4 col : COLOR0;
	float4 tex : TEXCOORD0;
};

struct vsinput_mesh
{
	float3 pos : POSITION0;
	float3 nrm : NORMAL0;
	float4 tan : TANGENT0;
	float4 col : COLOR0;
#ifdef SKIN
	float4 wts : BLENDWEIGHT0;
	BLENDIDX_UINT8_4_TYPE idcs : BLENDINDICES0;
#endif
	float4 tex0 : TEXCOORD0;
	float4 tex1 : TEXCOORD1;
};

struct VS2PS
{
	float4 tex0 : TEXCOORD0;
	float4 tex1 : TEXCOORD1;
	float3 viewPos : TEXCOORD2;
	float3 N : TEXCOORD3;
	float4 T : TEXCOORD4;
	float4 col : COLOR0;
	SGRX_SPOTLIGHT_DATA( 5, 6 )
	float4 pos : SEMANTIC_VSOUT_POS;
};

struct SurfaceInput
{
	float3 viewPos;
	float4 projPos;
	float3 viewDir;
	float4 inTex0;
	float4 inTex1;
	float3 inNormal;
	float4 inTangentSign;
	float4 icol;
	float3x3 TBN;
};

struct SurfaceInfo
{
	float4 diffuseColor;
	float3 specularColor;
	float glossiness;
	float3 normal;
	float2 distortion;
	float3 emissiveLight;
};

void InitSurfaceInfo( out SurfaceInfo info )
{
	info.diffuseColor = float4( 0.7, 0.7, 0.7, 1 );
	info.specularColor = float3( 0.3, 0.3, 0.3 );
	info.glossiness = 0.5;
	info.normal = float3( 0, 0, 1 );
	info.distortion = float2( 0, 0 );
	info.emissiveLight = float3( 0, 0, 0 );
}


#ifndef LIGHT_MULTIPLIER
#define LIGHT_MULTIPLIER 4
#endif


__CODE__


#if VS


#ifdef PARTICLE
void main( vsinput_particle i, out VS2PS vsout )
{
	float3 viewPos = ModelToViewPos( i.pos );
	vsout.pos = ViewToProjPos( viewPos );
	vsout.viewPos = viewPos;
	vsout.N = float3(0,0,-1);
	vsout.T = float4(1,0,0,1);
	vsout.col = i.col;
	vsout.tex0 = i.tex;
	vsout.tex1 = i.tex;
}
#else // PARTICLE

void main( vsinput_mesh i, out VS2PS vsout )
{
	SGRX_SKIN_MESH( i );
	float3 worldPos = ModelToWorldPos( i.pos );
	vsout.T = float4( ModelToWorldDir( i.tan.xyz ), i.tan.w );
	vsout.N = ModelToWorldDir( i.nrm );
	vsout.col = i.col;
	vsout.tex0 = i.tex0;
	vsout.tex1 = i.tex1;
	{
//__VSCODE__
	}
	vsout.N = WorldToViewDir( vsout.N );
	vsout.T.xyz = WorldToViewDir( vsout.T.xyz );
	float3 viewPos = WorldToViewPos( worldPos );
	vsout.pos = ViewToProjPos( viewPos );
	vsout.viewPos = viewPos;
	SGRX_SPOTLIGHT_VS_TRANSFER( vsout, worldPos );
}

#endif // PARTICLE


#elif PS

void ApplyPointLight( inout float3 totalDiffuse, inout float3 totalSpecular,
	PointLight PL, float3 viewPos, float3 viewNormal, float specPower, float3 rgbmult )
{
	float3 viewDir = normalize( viewPos );
	float3 lightViewPos = PL.vposrad.xyz;
	float3 lightDir = lightViewPos - viewPos;
	float lightDist = length( lightDir );
	lightDir /= lightDist;
	float3 lightColor = PL.colpow.rgb * rgbmult;
	
	float distFactor = pow( 1 - saturate( lightDist / PL.vposrad.w ), PL.colpow.w );
	float NdotL = saturate( dot( viewNormal, lightDir ) );
	
	float NdotH = saturate( dot( viewNormal, normalize( lightDir - viewDir ) ) );
	float specAmount = pow( NdotH, specPower ) * sqrt( specPower );
	
	totalDiffuse += lightColor * NdotL * distFactor;
	totalSpecular += lightColor * specAmount * distFactor;
}

bool PostProjCoordToTexDepth( out float3 slpos, float4 coord )
{
	float3 pos = coord.xyz / coord.w;
	slpos = float3( pos.xy * float2(0.5, -0.5) + 0.5, pos.z );
	return dot(step(1-abs( pos ),0),1) <= 0;
}

float3 StaticDiffuseLighting( float3 worldNormal, float dotVertBumpNormal, float2 lmTex )
{
	float4 contribData = TEXSAMPLE_2D( InstTex1, lmTex );
	// brightness compensation value
	float BRDot = saturate( dotVertBumpNormal ) * 0.9 + 0.1;
	// contribution [dot] surface normal
	float LMDot = saturate( dot( contribData.xyz * 2 - 1, worldNormal ) );
	return TEXSAMPLE_2D( InstTex0, lmTex ).rgb * lerp( 1, LMDot / BRDot, contribData.w );
}

float3 DynamicDiffuseLighting( float3 worldNormal )
{
	float qxp = saturate( worldNormal.x ), qxn = saturate( -worldNormal.x );
	float qyp = saturate( worldNormal.y ), qyn = saturate( -worldNormal.y );
	float qzp = saturate( worldNormal.z ), qzn = saturate( -worldNormal.z );
	return (
		qxp * gInstanceData[10].rgb + qxn * gInstanceData[11].rgb +
		qyp * gInstanceData[12].rgb + qyn * gInstanceData[13].rgb +
		qzp * gInstanceData[14].rgb + qzn * gInstanceData[15].rgb )
		/ (qxp+qyp+qzp+qxn+qyn+qzn);
}

void main
(
	VS2PS input
	
#if !defined(SHADOW_PASS) || SHADOW_PASS_TO_RT
	ARG_OUT_RT0
#endif
#ifndef SHADOW_PASS
	ARG_OUT_RT1
	ARG_OUT_RT2
#endif // SHADOW_PASS
)
{
	float3 inViewPos = input.viewPos.xyz;
	float3 viewPos = inViewPos;
	float4 projPos = mul( mProj, float4( input.viewPos, 1 ) );
	float3 viewDir = normalize( viewPos );
	float4 inTex0 = input.tex0;
	float4 inTex1 = input.tex1;
	float3 inNormal = input.N;
	float4 inTangentSign = input.T;
	float4 icol = input.col;
	
	float3x3 TBN = CreateTBNMatrix( input.N, input.T );
	
	SurfaceInfo surfInfo;
	InitSurfaceInfo( surfInfo );
	
	surf( surfInfo, input );
	
#ifdef SHADOW_PASS
#if SHADOW_PASS_TO_RT
	RT0 = float4( projPos.z / projPos.w, 0, 0, 1 );
#endif
#else
	
	float outSpecularPower = exp2( surfInfo.glossiness * 8 );
	float3 outNormal = normalize( mul( surfInfo.normal, TBN ) );
	
	float3 refView = reflect( viewDir, outNormal );
	float3 refWorld = ViewToWorldDir( refView );
	
	float3 totalDiffuse = float3(0,0,0);
	float3 totalSpecular = float3(0,0,0);
	
#ifdef BASE_PASS
	
#if LMODE == 1 || LMODE == 3 // -- static / decal
	totalDiffuse += StaticDiffuseLighting( ViewToWorldDir( outNormal ), dot( outNormal, inNormal ), inTex1.xy );
#elif LMODE == 2 // -- dynamic
	totalDiffuse += DynamicDiffuseLighting( ViewToWorldDir( outNormal ) );
#endif // LMODE
	
#if defined(VCOL)
	totalDiffuse *= icol.rgb;
#endif // defined(VCOL)
	totalDiffuse *= LIGHT_MULTIPLIER;
	
	// environment cubemap
	totalSpecular += TEXSAMPLE_CUBE_BIAS( InstTex2, refWorld, ( 1 - surfInfo.glossiness ) * 8 ).rgb;
	// screen-space reflections
	totalSpecular += TEXSAMPLE_2D( InstTex3, projPos.xy / projPos.w * float2(-0.5,-0.5) + 0.5 ).rgb;
	
	// totalDiffuse += gAmbLightColor;
	/* DIRECTIONAL LIGHT *--disabled--/
	totalDiffuse += saturate( dot( outNormal, gDirLightDir ) ) * gDirLightColor;
	RdotV = saturate( dot( reflect( gDirLightDir, outNormal ), viewDir ) );
	specAmount = pow( RdotV, outSpecularPower ) * sqrt( outSpecularPower );
	totalSpecular += gDirLightColor * specAmount; */
#endif // BASE_PASS
	
#ifdef VCOL
	surfInfo.diffuseColor.a *= icol.a;
#endif // VCOL
	
#ifdef NUM_POINTLIGHTS
	/* POINT LIGHTS */
	for( int i = 0; i < gLightCounts.x; ++i )
	{
		ApplyPointLight( totalDiffuse, totalSpecular, gPLights[i],
			viewPos, outNormal, outSpecularPower, float3(1,1,1) );
	}
#endif // NUM_POINTLIGHTS
	
#ifdef NUM_SPOTLIGHTS
	/* SPOT LIGHTS */
	if( gLightCounts.y > 0 )
	{
		float3 slpos;
		if( PostProjCoordToTexDepth( slpos, input.SLPPos0 ) )
		{
			SpotLight SL = gSLights[0];
			ApplyPointLight( totalDiffuse, totalSpecular, SL.PL, viewPos, outNormal, outSpecularPower,
				TEXSAMPLE_2D_LOD( Tex12, slpos.xy, 0 ) * SHADOWMAP_2x2( Tex13, SL.shminfo, slpos.xy, slpos.z ) );
		}
	}
	if( gLightCounts.y > 1 )
	{
		float3 slpos;
		if( PostProjCoordToTexDepth( slpos, input.SLPPos1 ) )
		{
			SpotLight SL = gSLights[1];
			ApplyPointLight( totalDiffuse, totalSpecular, SL.PL, viewPos, outNormal, outSpecularPower,
				TEXSAMPLE_2D_LOD( Tex14, slpos.xy, 0 ) * SHADOWMAP_2x2( Tex15, SL.shminfo, slpos.xy, slpos.z ) );
		}
	}
#endif // NUM_SPOTLIGHTS
	
	// PRE-LIGHT modifier addons
#if LMODE == 0 || defined(MOD_UNLIT) // -- unlit
	totalDiffuse = float3(1,1,1);
	totalSpecular = float3(0,0,0);
#endif
	
	float3 diffuseCol = surfInfo.diffuseColor.rgb;
#if defined(MOD_NODIFFCOL) // -- ignore diffuse color
	diffuseCol = float3(1,1,1);
#endif
	
	float opacity = surfInfo.diffuseColor.a;
	RT0 = float4( totalDiffuse * diffuseCol + totalSpecular * surfInfo.specularColor + surfInfo.emissiveLight, opacity );
	RT1 = float4( surfInfo.distortion, 0, opacity );
	RT2 = float4( inViewPos.z, 0, 0, 1 );
	
	// POST-LIGHT modifier addons
#ifdef MOD_BLENDCOLOR
	RT0.rgb = lerp( RT0.rgb,
		gInstanceData[ MOD_BLENDCOLOR ].rgb,
		gInstanceData[ MOD_BLENDCOLOR ].a );
#endif
	
#endif // SHADOW_PASS
}

#endif

