
include "io", "os", "re", "string";

global DB_NAME = "contentproc.db";

global GDIR = "./";
global G_DB = {};


function path_normalize( path )
{
	return string_replace( path, "\\", "/" );
}


function _file_get_timestamp( file )
{
	stat = @io_stat( file );
	if( stat !== null )
		return if( stat.mtime > stat.ctime, stat.mtime, stat.ctime );
	return null;
}

function _now_timestamp()
{
	return os_time();
}


function _db_load()
{
	if( io_file_exists( DB_NAME ) == false )
		return;
	data = io_file_read( DB_NAME );
	global G_DB = unserialize( data );
}

function _db_save()
{
	io_file_write( DB_NAME, serialize( G_DB ) );
}

function _db_get_cmd_timestamp( cmd )
{
	return @G_DB[ cmd ];
}

function _db_set_cmd_timestamp( cmd )
{
	G_DB[ cmd ] = _now_timestamp();
}


function iterate_files( func, basedir )
{
	basedir ??= GDIR;
	foreach( is_real, entry : io_dir( basedir ) )
	{
		if( !is_real )
			continue;
		fn = basedir $ entry;
		if( io_file_exists( fn ) )
			func( fn );
		if( io_dir_exists( fn ) )
			iterate_files( func, fn $ "/" );
	}
}

function directory( dir )
{
	println( "DIRECTORY: " $ dir );
	
	dir = path_normalize( tostring( dir ) );
	if( dir && dir[ dir.length - 1 ] != "/" )
		dir $= "/";
	global GDIR = dir;
}

function do_command( cmd )
{
	println( "> COMMAND: " $ string_implode( cmd, " " ) );
	
	app = cmd[0];
	if( app == "copy" )
	{
		data = io_file_read( cmd[1] );
		if( data !== null )
			io_file_write( cmd[2], data );
	}
	else
	{
		cmd = clone( cmd );
		app = "..\\bin\\" $ app;
		cmd[0] = app;
		os_command( string_implode( cmd, " " ) );
	}
}

global GPROC_REGEX_MAP =
{
	"*" = "(.*?)",
	"%" = "([^/]*?)",
};
function process( cmd, inout )
{
	println( "PROCESS: " $ string_implode( cmd, " " ) );
	println( "- IN/OUT: " $ dumpvar( inout ) );
	
	foreach( inputs, outputs : inout )
	{
		re_inputs = "%^" $ string_translate( inputs, GPROC_REGEX_MAP ) $ "$%i";
		iterate_files(function( filename ) use( inputs, re_inputs, outputs, cmd )
		{
			fn = string_part( filename, GDIR.length );
			matches = re_match( fn, re_inputs, RE_RETURN_CAPTURED );
			if( matches )
			{
				matches.shift();
				outparts = string_explode( outputs, "%" );
				inspos = 1;
				foreach( match : matches )
				{
					if( inspos > outparts.size )
						break;
					outparts.insert( inspos, match );
					inspos += 2;
				}
				output_filename = GDIR $ string_implode( outparts, "" );
				
				// substitute arguments in command
				subst = { "$IN" = filename, "$OUT" = output_filename };
				scmd = array_process( clone( cmd ), function( v ) use( subst )
					{ return string_translate( v, subst ); } );
				scmd_str = string_implode( scmd, " " );
				
				// check command source file timestamp
				ts_infile = _file_get_timestamp( filename );
				if( ts_infile == null )
				{
					WARNING( "input file not found: " $ filename );
					return;
				}
				ts_cmd = _db_get_cmd_timestamp( scmd_str );
				if( io_file_exists( output_filename ) && ts_cmd > ts_infile )
				{
					println( "skipped: " $ scmd_str );
					return;
				}
				
				// run command
				do_command( scmd );
				_db_set_cmd_timestamp( scmd_str );
			}
		},
		GDIR );
	}
}




if( isset( _G, argv ) )
	ERROR( "Application isn't run in program mode (sgsvm -p)" );
if( argv.size < 2 )
	ERROR( "Missing argument 1 - application name" );
APPNAME = argv[1];
if( io_file_exists( "contentproc.running" ) )
	ERROR( "Content processor is already running! If this is not true, delete contentproc.running" );
io_file_write( "contentproc.running", "" );

_db_load();

pcall(function() use( APPNAME )
{
	include_file( APPNAME $ ".build.sgs" );
},
function(){ return SGS_WARNING; });

_db_save();

io_file_delete( "contentproc.running" );

